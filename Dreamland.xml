<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Dreamland UI</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>prompt trigger</name>
				<script>dhb.stats.health = tonumber(multimatches[2][2])
dhb.stats.maxhealth = tonumber(multimatches[2][3])
dhb.stats.mana = tonumber(multimatches[2][4])
dhb.stats.maxmana = tonumber(multimatches[2][5])
dhb.stats.steps = tonumber(multimatches[2][6])
dhb.stats.maxsteps = tonumber(multimatches[2][7])
dhb.stats.mypercent, dhb.stats.targetpercent = nil, nil</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>&lt;</string>
					<string>&lt;(\d+)/(\d+)зд (\d+)/(\d+)ман (\d+)/(\d+)шг (\d+)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>combat</name>
					<script>dhb.stats.mypercent = tonumber(matches[2])
dhb.stats.targetpercent = tonumber(matches[3])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\[(\d+)%:(\d+)%\]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Raise prompt event</name>
					<script>raiseEvent("dhb on prompt")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>return true</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>4</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Dreamland mapper script</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Can't go there</name>
				<script>raiseEvent("onMoveFail")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Извини, но ты не можешь туда идти.</string>
					<string>Жаль, но ты не можешь туда идти.</string>
					<string>Ты не можешь войти в чужую гильдию.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Random movement</name>
				<script>raiseEvent("onRandomMove")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Ты убегаешь с поля битвы!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Can't see</name>
				<script>raiseEvent("onVisionFail")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Здесь слишком темно ... </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Dreamland tabbed chat</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>OOC</name>
				<script>demonnic.chat:append("OOC")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>[ooc]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Auction</name>
				<script>demonnic.chat:append("Auction")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string> AUCTION:</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Dreamland</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Stop speedwalking</name>
				<script>dhb.stopwalking()</script>
				<command></command>
				<packageName></packageName>
				<regex>^mstop$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Dreamland UI</name>
			<packageName></packageName>
			<script> -- initial UI by Vadi
 
 dhb = dhb or {
  stats = {
    health = 0,
    maxhealth = 10,
    mana = 0,
    maxmana = 100,
    steps = 0,
    maxsteps = 100
	},
	ui = {},
	version = 0.3
}</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>UI</name>
				<packageName></packageName>
				<script>local function addstyling(gauge, color)
  gauge:setStyleSheet([[
    border-width: 1px; border-style: solid; border-radius: 5px; background-color: ]]..color)
end

dhb.bottompanel = Geyser.HBox:new({
  name="bottompanel",
  x=0, y="-3%",
  width="100%", height="3%",
})
setBorderBottom(dhb.bottompanel:get_height())

dhb.healthbox = Geyser.HBox:new({name="dhb.healthbox"}, dhb.bottompanel)
dhb.healthbar = Geyser.Gauge:new({name="healthbar"}, dhb.healthbox)
addstyling(dhb.healthbar.front, "#BB0000")
addstyling(dhb.healthbar.back, "#630000")

dhb.enemyhealthbar = Geyser.Gauge:new({name="enemyhealthbar"}, dhb.healthbox)
addstyling(dhb.enemyhealthbar.front, "#990000")
addstyling(dhb.enemyhealthbar.back, "#420000")

dhb.manabar = Geyser.Gauge:new({name="manabar"}, dhb.bottompanel)
addstyling(dhb.manabar.front, "#3465A4")
addstyling(dhb.manabar.back, "#182f4c")

dhb.stepsbar = Geyser.Gauge:new({name="stepsbar"}, dhb.bottompanel)
addstyling(dhb.stepsbar.front, "#055705")
addstyling(dhb.stepsbar.back, "#0aab0a")

function dhb.ui.updatestats()
  dhb.healthbar:setValue(dhb.stats.health, dhb.stats.maxhealth)
  dhb.healthbar:setText(string.format(
	  "&lt;center&gt;Здоровье %d/%d&lt;/center&gt;", dhb.stats.health, dhb.stats.maxhealth))
		
  dhb.manabar:setValue(dhb.stats.mana, dhb.stats.maxmana)
  dhb.manabar:setText(string.format(
	  "&lt;center&gt;Мана %d/%d&lt;/center&gt;", dhb.stats.mana, dhb.stats.maxmana))
		
  dhb.stepsbar:setValue(dhb.stats.steps, dhb.stats.maxsteps)
  dhb.stepsbar:setText(string.format(
	  "&lt;center&gt;Шаги %d/%d&lt;/center&gt;", dhb.stats.steps, dhb.stats.maxsteps))
end

function dhb.ui.updatecombat()
  if not dhb.stats.targetpercent then
	  dhb.enemyhealthbar:hide()
		dhb.enemyhealthbar.h_stretch_factor = 0
		dhb.healthbar.h_stretch_factor = 2
    dhb.healthbox:organize()
		dhb.healthbox:reposition()
		return
	end
	
	dhb.healthbar.h_stretch_factor = 1
	dhb.enemyhealthbar.h_stretch_factor = 1
	dhb.enemyhealthbar:setValue(dhb.stats.targetpercent, 100)
	dhb.enemyhealthbar:show()
  dhb.healthbox:organize()
	dhb.healthbox:reposition()
end


registerAnonymousEventHandler("dhb on prompt", "dhb.ui.updatestats")
registerAnonymousEventHandler("dhb on prompt", "dhb.ui.updatecombat")

raiseEvent("dhb on prompt")</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Dreamland mapper script</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Simple Window Manager</name>
				<packageName></packageName>
				<script>-- Window Manager Script --
--  Zachary Hiland
--  10/22/2016
--  v2.00c
--
--  Functions Details
--
--      windowManager.create(name, type, x, y, width, height, origin, [font_size]) or windowManager.add(info_table)
--      creates a window and adds it to the windowManager
--
--      info_table must have a valid entry for each argument, by the same name, as in the normal function call
--      name - name of already created window (label, miniConsole, gauge, mapper, menu, or autowrap)
--          Note: for a mapper window, use any name you like, so long as it isn't the name of some other object
--      type - identify the type of window, must be label, miniConsole, gauge, mapper, or menu
--      x - distance horizontally from the origin corner
--      y - distance vertically from the origin corner
--      width - width of window
--      height - height of window
--      origin - corner to act as origin for this window, must be topleft, topright, bottomleft, or bottomright
--      font_size - only used for autowrap windows, will be automatically set as the font size for the created window
--
--      note: all measurements should be numbers, or strings with values measured in percent or pixels (or unlabeled)
--          if a measurement contains both percent and pixel values (or multiple values of the same type), they should be separated
--          by a "+" symbol. Example: "25% + 50px + 16"
--      important: no negative numbers
--
--      windowManager.add(name, type, x, y, width, height, origin, font_size) or windowManager.create(info_table)
--      adds an already created window to the windowManager, uses the exact same arguments as those in the "create" function
--
--      windowManager.remove(name)
--      removes a window from the windowManager
--
--      windowManager.move(name, x, y)
--      moves a window with the windowManager
--
--      windowManager.resize(name, width, height)
--      resizes a window with the windowManager
--
--      windowManager.relocate(name, origin)
--      changes the corner acting as the origin for a window in the windowManager
--
--      windowManager.show(name)
--      shows a window that is managed by windowManager (you can also use showWindow or showGauge functions)
--          Note: this is only really important for a mapper window
--
--      windowManager.hide(name)
--      hides a window that is managed by windowManager (you can also use hideWindow or hideGauge functions)
--          Note: this is only really important for a mapper window
--
--      windowManager.getValue(name, value)
--      returns the calculated size or position values, or the origin, for a window in the windowManager
--
--      windowManager.math(value1, value2, operation)
--      allows addition and subtraction of measurements with each other,
--      and multiplication and division of a measurement by a normal number
--
--      windowManager.simplify(measurement)
--      returns a simplified version of a measurement (all percent and pixel values are combined together)
--
--      windowManager.refresh(name)
--      sets the size and location of a window in the windowManager using previously set values
--      note: generally this function does not need to be called
--
--      windowManager.refreshAll()
--      note: this function is called automatically when a sysWindowResizeEvent event occurs,
--          and generally does not need to be called manually
--
--      windowManager.createBuffer(name)
--      creates a buffer to be used with an autowrap window, only needed if miniconsole added manually to windowManager
--
--      windowManager.append(name)
--      appends text to an autowrap window, works just like appendBuffer()
--
--      windowManager.echo(name, text)
--      echoes text to an autowrap window. cecho, decho, and hecho are also available.
--
--      windowManager.clear(name)
--      clears an autowrap window.
--
--      windowManager.setFontSize(name, font_size)
--      sets the font size for an autowrap window.

windowManager = windowManager or {}
windowManager.list = windowManager.list or {}

local function calcScaledNum(scale,num)
    scale_table = string.split(scale," %+ ")
    if #scale_table &gt; 2 then
        scale = windowManager.simplify(scale)
        scale_table = string.split(scale," %+ ")
    end
    scale = 0
    if #scale_table == 2 then
        scale = string.cut(scale_table[1],#scale_table[1] - 1) * num / 100
        scale = scale + string.gsub(scale_table[2],"px","")
    elseif string.find(scale_table[1],"%%") then
        scale = string.cut(scale_table[1],#scale_table[1] - 1) * num / 100
    else
        scale = string.gsub(scale_table[1],"px","")
    end
    scale = math.floor(scale + 0.5)
    return scale
end

local function rewrap_window(name)
    local info = windowManager.list[name]
    local buffer = name .. "_windowManager_buffer"
    local wrap = math.floor(windowManager.getValue(name,"width") / calcFontSize(info.font))
    local line, moved
    setWindowWrap(name,wrap)
    clearWindow(name)
    line = 0
    moved = moveCursor(buffer,1,line)
    while moved do
        selectCurrentLine(buffer)
        copy(buffer)
        line = line + 1
        moved = moveCursor(buffer,1,line)
        appendBuffer(name)
    end
end

function windowManager.simplify(measure)
    measure = string.gsub(measure,"%s*-%s*([%d%%]+)"," + -%1")
    measure = string.gsub(measure,"%-%-","")
    measure = string.gsub(measure,"%+%s*%+","+")
    measure = string.gsub(measure,"^%s*%+","")
    local measure_table = string.split(measure,"+")
    local percent, pixel = 0,0
    for k,v in ipairs(measure_table) do
        v = string.trim(v)
        if string.find(v,"%%") then
            v = string.gsub(v,"%%","")
            if not tonumber(v) then display(measure) end
            percent = percent + v
        elseif v ~= "" then
            v = string.gsub(v,"px","")
            if not tonumber(v) then display(measure) end
            pixel = pixel + v
        end
    end
    percent = math.floor(1000 * percent + .5) / 1000
    pixel = math.floor(1000 * pixel + .5) / 1000
    if percent == 0 then
        measure = pixel .. "px"
    elseif pixel == 0 then
        measure = percent .. "%"
    else
        measure = percent .. "% + " .. pixel .. "px"
    end
    return measure
end

function windowManager.math(measure,num,op)
    if not table.contains({"multiply","divide", "add", "subtract"},op) then
        error("windowManager.math: bad argument #3 \"operation\", must be add, subtract, multiply or divide",2)
    end
    if op == "divide" or op == "multiply" then
        if string.find(num,"%%") then
            num = string.gsub(num,"%%","") / 100
        end
        if not tonumber(num) then
            error("windowManager.math: bad argument #2 \"num\", must be a number",2)
        end
        num = tonumber(num)
        measure = string.gsub(measure,"%s*-%s*([%d%%]+)"," + -%1")
        measure = string.gsub(measure,"%+%s*%+","+")
        measure = string.gsub(measure,"^%s*%+","")
        local measure_table = string.split(measure,"+")
        if op == "divide" then num = 1 / num end
        for k,v in ipairs(measure_table) do
            v = string.trim(v)
            v = (string.gsub(v,"([%d%.]+).*","%1") * num) .. string.gsub(v,".*[%d%.]+(.*)","%1")
            measure_table[k] = v
        end
        measure = table.concat(measure_table," + ")
    else
        if op == "subtract" then
            num = windowManager.math(num,"-1","multiply")
        end
        measure = measure .. " + " .. num
        measure = string.gsub(measure,"([^%s%+%-]+)%s*-%s*([%d%.%-]+)","%1 + -%2")
    end
    return windowManager.simplify(measure)
end

function windowManager.create(name, window_type, ...)
    local tbl = {}
    local is_table = false
    if type(name) == "table" then
        table.update(tble,name)
        name = tbl.name
        window_type = tbl.type
        is_table = true
    end
    if type(window_type) ~= "string" then
        error("windowManager.create: bad argument #2 \"type\", must be string.",2)
    end
    window_type = string.lower(window_type)
    if not table.contains({"label","miniconsole","gauge","mapper","menu","autowrap"},window_type) then
        error("windowManager.create: invalid type",2)
    end
    if window_type == "label" then
        createLabel(name, 0,0,0,0,1)
    elseif window_type == "miniconsole" then
        createMiniConsole(name,0,0,0,0)
    elseif window_type == "gauge" then
        createGauge(name,0,0,0,0)
    elseif window_type == "menu" then
        createMenu(name,0,0,0,0)
    elseif window_type == "autowrap" then
        createMiniConsole(name,0,0,0,0)
        createBuffer(name .. "_windowManager_buffer")
        setWindowWrap(name .. "_windowManager_buffer",1000)
    end
    if is_table then
        return windowManager.add(tbl)
    else
        return windowManager.add(name, window_type, ...)
    end
end

function windowManager.makeBuffer(name)
    createBuffer(name .. "_windowManager_buffer")
    setWindowWrap(name .. "_windowManager_buffer",1000)
end

function windowManager.add(name, window_type, x, y, w, h, origin, font)
    local tbl = {}
    if type(name) == "table" then
        tbl = table.update(tbl,name)
        name = tbl.name
        x = tbl.x
        y = tbl.y
        w = tbl.width
        h = tbl.height
        origin = tbl.origin
        window_type = tbl.type
        font = tbl.font_size
        tbl = {}
    end
    font = font or 10
    if not name then
        error("windowManager.add: bad argument #1 \"name\".",2)
    end
    windowManager.list[name] = nil
    if type(window_type) ~= "string" then
        error("windowManager.add: bad argument #2 \"type\", must be string.",2)
    end
    window_type = string.lower(window_type)
    if not table.contains({"label","miniconsole","gauge","mapper","menu","autowrap"},window_type) then
        error("windowManager.add: invalid type",2)
    end
    if not (x and y and w and h) then
        error("windowManager.add: must have x, y, width, and height.",2)
    end
    origin = origin or "topleft"
    origin = string.lower(origin)
    if not table.contains({"topleft","topright","bottomleft","bottomright"},origin) then
        error("windowManager.add: bad argument #7 \"origin\".",2)
    end
    x = windowManager.simplify(x)
    y = windowManager.simplify(y)
    w = windowManager.simplify(w)
    h = windowManager.simplify(h)
    tbl = {
        type = window_type,
        x = x, y = y, h = h, w = w,
        origin = origin}
    if window_type == "autowrap" then
        tbl.font = font
        setMiniConsoleFontSize(name, font)
    end
    windowManager.list[name] = tbl
    windowManager.refresh(name)
end

function windowManager.remove(name)
    windowManager.list[name] = nil
end

function windowManager.refresh(name, main_w, main_h)
    local info = windowManager.list[name]
    if not info then error("windowManager.refresh: no such window.",2) end
    local x,y,w,h,origin,win_type = info.x, info.y, info.w, info.h, info.origin, info.type
    if not (main_w and main_h) then
        main_w, main_h = getMainWindowSize()
    end
    w = calcScaledNum(w,main_w)
    x = calcScaledNum(x,main_w)
    h = calcScaledNum(h,main_h)
    y = calcScaledNum(y,main_h)
    if string.find(origin,"right") then
        x = main_w - x - w
    end
    if string.find(origin,"bottom") then
        y = main_h - y - h
    end
    if win_type == "gauge" then
        moveGauge(name,x,y)
        resizeGauge(name,w,h)
    elseif win_type == "mapper" then
        if not info.hide then
            createMapper(x,y,w,h)
        end
    elseif win_type == "menu" then
        moveMenu(name,x,y)
        resizeMenu(name,w,h)
    else
        moveWindow(name,x,y)
        resizeWindow(name,w,h)
        if win_type == "autowrap" then
            rewrap_window(name)
        end
    end
end

function windowManager.resize(name, w, h)
    local info = windowManager.list[name]
    if not info then error("windowManager.resize: no such window.",2) end
    if not (w and h) then error("windowManager.resize: must have both width and height.",2) end
    w = windowManager.simplify(w)
    h = windowManager.simplify(h)
    windowManager.list[name].w = w
    windowManager.list[name].h = h
    windowManager.refresh(name)
end

function windowManager.move(name, x, y)
    local info = windowManager.list[name]
    if not info then error("windowManager.move: no such window.",2) end
    if not (x and y) then error("windowManager.move: must have both x and y.",2) end
    x = windowManager.simplify(x)
    y = windowManager.simplify(y)
    windowManager.list[name].x = x
    windowManager.list[name].y = y
    windowManager.refresh(name)
end

function windowManager.relocate(name, origin)
    local info = windowManager.list[name]
    if not info then error("windowManager.relocate: no such window.",2) end
    origin = origin or "topleft"
    origin = string.lower(origin)
    if not table.contains({"topleft","topright","bottomleft","bottomright"},origin) then
        error("windowManager.relocate: bad argument #2 \"origin\".",2)
    end
    windowManager.list[name].origin = origin
    windowManager.refresh(name)
end

function windowManager.hide(name)
    local info = windowManager.list[name]
    if not info then error("windowManager.hide: no such window.",2) end
    local info = windowManager.list[name]
    if info.type == "gauge" then
        hideGauge(name)
    elseif info.type == "mapper" then
        windowManager.list[name].hide = true
        createMapper(0,0,0,0)
    elseif info.type == "menu" then
        hideMenu(name)
    else
        hideWindow(name)
    end
end

function windowManager.show(name)
    local info = windowManager.list[name]
    if not info then error("windowManager.show: no such window.",2) end
    local info = windowManager.list[name]
    if info.type == "gauge" then
        showGauge(name)
    elseif info.type == "mapper" then
        windowManager.list[name].hide = false
        windowManager.refresh(name)
    elseif info.type == "menu" then
        showMenu(name)
    else
        showWindow(name)
    end
end

function windowManager.setFontSize(name, font_size)
    local info = windowManager.list[name]
    if not info then error("windowManager.setFontSize: no such window.",2) end
    windowManager.list[name].font = font_size
    setMiniConsoleFontSize(name, font_size)
    windowManager.refresh(name)
end

function windowManager.clear(name)
    local info = windowManager.list[name]
    if not info then error("windowManager.clear: no such window.",2) end
    clearWindow(name)
    clearWindow(name .. "_windowManager_buffer")
end

function windowManager.append(name)
    local info = windowManager.list[name]
    if not info then error("windowManager.append: no such window.",2) end
    appendBuffer(name)
    appendBuffer(name .. "_windowManager_buffer")
end

function windowManager.echo(name, text)
    local info = windowManager.list[name]
    if not info then error("windowManager.echo: no such window.",2) end
    echo(name, text)
    echo(name .. "_windowManager_buffer", text)
end

function windowManager.cecho(name, text)
    local info = windowManager.list[name]
    if not info then error("windowManager.cecho: no such window.",2) end
    cecho(name, text)
    cecho(name .. "_windowManager_buffer", text)
end

function windowManager.hecho(name, text)
    local info = windowManager.list[name]
    if not info then error("windowManager.hecho: no such window.",2) end
    hecho(name, text)
    hecho(name .. "_windowManager_buffer", text)
end

function windowManager.decho(name, text)
    local info = windowManager.list[name]
    if not info then error("windowManager.decho: no such window.",2) end
    decho(name, text)
    decho(name .. "_windowManager_buffer", text)
end

function windowManager.getValue(name, value)
    local info = windowManager.list[name]
    if not info then error("windowManager.getValue: no such window.",2) end
    if not table.contains({"x","y","width","height","w","h","origin"},value) then
        error("windowManager.getValue: no such value.",2)
    end
    local sys_w, sys_h = getMainWindowSize()
    if value == "width" then value = "w" end
    if value == "height" then value = "h" end
    local tmp = windowManager.list[name][value]
    if value == "w" or value == "x" then
        tmp = calcScaledNum(tmp,sys_w)
    elseif value == "h" or value == "y" then
        tmp = calcScaledNum(tmp,sys_h)
    end
    return tmp
end

function windowManager.refreshAll()
    local main_w, main_h = getMainWindowSize()
    for k,v in pairs(windowManager.list) do
        windowManager.refresh(k, main_w, main_h)
    end
end

registerAnonymousEventHandler("sysWindowResizeEvent", "windowManager.refreshAll")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Generic Mapper Config</name>
				<packageName></packageName>
				<script>map.configs = map.configs or {}
map.configs.show_map = false
map.configs.speedwalk_random = false
map.configs.speedwalk_delay = 0.01</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>SetGMCPRoomName</name>
				<packageName></packageName>
				<script>function SetGMCPRoomName()
  map.prompt.hash = gmcp.Room.Info.num and tostring(gmcp.Room.Info.num)
  map.prompt.room = gmcp.Room.Info.name
  map.prompt.exits = gmcp.Room.Info.exits and table.concat(table.keys(gmcp.Room.Info.exits), " ")
  raiseEvent("onNewRoom",map.prompt.exits)
  if map.mapping and gmcp.Room.Info.area and gmcp.Room.Info.area ~= map.currentArea then
    map.set_area(gmcp.Room.Info.area)
  end
end</script>
				<eventHandlerList>
					<string>gmcp.Room.Info</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>YATCOCONFIG</name>
			<packageName></packageName>
			<script>demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.config = demonnic.chat.config or {}</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Configuration Options (container)</name>
				<packageName></packageName>
				<script>dhb.ui.mapchat = Geyser.Container:new({
  name = "dhb.ui.mapchat",
	x = "-40%",
  y = 0,
  width = "30%",
  height = "80%"
})

dhb.ui.chat = Geyser.Container:new({
  name = "dhb.ui.chat",
	x = 0,
	y = "50%",
	width = "100%",
	height = "50%"
}, dhb.ui.mapchat)

dhb.ui.mapper = Geyser.Mapper:new({
  name = "dhb.ui.mapper",
  x = 0, y = 0,
  width = "100%",
  height = "50%",
}, dhb.ui.mapchat)

-- reposition timer after YATCO is up
tempTimer(1, function() dhb.ui.mapper:reposition() end)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Configuration Options</name>
				<packageName></packageName>
				<script>--[[
This is a table of channels you would like.
AKA the place you tell the script what tabs you want.
Each entry must be a string. The defaults should be a pretty effective guide.
]]

demonnic.chat.config.channels = {
  "All",
	"OOC",
  "City",
  "Auction",
}

--[[
This is where all of the configuration options can be set. 
Anything I've put in this script object can be changed, but please do pay attention to what you're doing.
If you change one of the values to something it shouldn't be, you could break it. 
]]

--This is where you tell it to use tabbed chat.
demonnic.chat.use = true

--[[
This is where you put what container to put the tabbed chat stuff into. Make it
equal to the actual container object you want it in, or false for none. Defaults to false
Which is to say if you want to put the tabbed chat stuff into a container made using 
uiRight = Geyser.Container:new()

you would put

demonnic.chat.useContainer = uiRight

and if you don't want it in a container you would put

demonnic.chat.useContainer = false
]]

demonnic.chat.useContainer = dhb.ui.chat

--[[
The timestamp option is set here.
Set to false if you do not want any timestamps displayed for chat.
If you do want it displayed, set to the string for the format you wish. 
see http://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for information
how to format the string
]]
demonnic.chat.config.timestamp = "HH:mm:ss"

--[[ Should we use our own colors for the timestamp?
Set to true if you want to specify foreground and background colors
for the timestamp.
Set to false if you want the timestamps background and foreground
colors to match that of the mud output.
]]
demonnic.chat.config.timestampCustomColor = false
--[[
and what foreground color? You can either use one of the 'named' colors
(see http://wiki.mudlet.org/images/c/c3/ShowColors.png for available colors)
demonnic.chat.config.timestampFG = "slate_grey"

Or you can use a table of R,G,B values. 
demonnic.chat.config.timestampFG = {
  255,
    0,
    0,
}
then the foreground for the timestamp would be 255 read, 100 green, and 0 blue
]]
demonnic.chat.config.timestampFG = "red"

--and background? Same rules as for the foreground above
demonnic.chat.config.timestampBG = "blue"

--[[
This is where you say what corner of the screen you want the tabbed chat on
Valid settings are "topright", "topleft", "bottomright", "bottomleft"
]]--
demonnic.chat.config.location = "topright"



--Set this to the name of the channel you want to have everything sent to. 
--Per the default, this would be the "All" channel. If you have a different name for it:
--
--demonnic.chat.config.Alltab = "Bucket"  
--
--And if you don't want it turned on at all:
--
--demonnic.chat.config.Alltab = false

demonnic.chat.config.Alltab = "All"

--Set this to the name of the channel you want to display your map. Set to "" if you
--don't want to display the map in your YATCO tabs
demonnic.chat.config.Maptab = ""


---------------------------------------------------------------------------------
--                                                                             --
--The infamous blinking stuff!!!                                               --
--                                                                             --
---------------------------------------------------------------------------------

--[[
Do you want tabs to blink when you get new messages, until you click on the tab?
True if yes, false if no.
]]
demonnic.chat.config.blink = true

--How long (in seconds) between blinks? For example, 1 would mean a 1 second pause in between blinks.
demonnic.chat.config.blinkTime = 3

--Blink if the bucket tab ("All" by default, but configured above) is in focus?
demonnic.chat.config.blinkFromAll = false




--Font size for the chat messages

demonnic.chat.config.fontSize = 9

--[[
Should we preserve the formatting of the text. 
Or should we set the background of it to match the window color?
Set this to false if you want the background for all chat to match the background of the window.
Useful if you change the background from black, and don't like the way the pasted chat makes blocks in it
]]

demonnic.chat.config.preserveBackground = false

--[[
Gag the chat lines in the main window?
defaults to false, set to true if you want to gag.
]]

demonnic.chat.config.gag = false

--[[
Number of lines of chat visible at once. 
Will determine how tall the window for the chats is.
]]

demonnic.chat.config.lines = 45

--[[
Number of characters to wrap the chatlines at.
This will also determine how wide the chat windows are.
]]

demonnic.chat.config.width = 60

--[[
Set the color for the active tab. R,G,B format.
The default here is a brightish green
]]

demonnic.chat.config.activeColors = {
  r = 0,
  g = 180,
  b = 0,
}

--[[
Set the color for the inactive tab. R,G,B format.
The default here is a drab grey
]]

demonnic.chat.config.inactiveColors = {
  r = 60,
  g = 60,
  b = 60,
}

--[[
Set the color for the chat window itself. R,G,B format.
Defaulted to the black of my twisted hardened soul. Or something.
]]

demonnic.chat.config.windowColors = {
  r = 0,
  g = 0,
  b = 0,
}

--[[
Set the color for the text on the active tab. Uses color names.
Set the default to purple. So the tab you're looking at, by default will be purple on bright green. 
Did I mention I'm a bit colorblind?
]]

demonnic.chat.config.activeTabText = "purple"

--[[
Set the color for the text on the inactive tabs. Uses color names.
Defaulted this to white. So the tabs you're not looking at will be white text on boring grey background.
]]

demonnic.chat.config.inactiveTabText = "white"

--[[
have to make sure a currentTab is set... 
so we'll use the one for the bucket, or the first one in the channels table
Or, you know... what it's currently set to, if it's already set.
]]
demonnic.chat.currentTab = demonnic.chat.currentTab or demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Demonnic</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Shared</name>
				<packageName></packageName>
				<script>--Bootstrapping variables/etc. Don't touch this unless you really know what you're doing

--I mean it. I'll point. AND laugh. loudly. 
demonnic = demonnic or {}
demonnic.config = demonnic.config or {}
demonnic.balances = demonnic.balances or {}
demonnic.balances.balance = demonnic.balances.balance or 1
demonnic.balances.equilibrium = demonnic.balances.equilibrium or 1
demonnic.debug = demonnic.debug or {}
demonnic.debug.active = demonnic.debug.active or nil
demonnic.debug.categories = demonnic.debug.categories or { }


function demonnic:echo(msg)
 cecho(string.format("\n&lt;blue&gt;(&lt;green&gt;Demonnic&lt;blue&gt;):&lt;white&gt; %s", msg))
end</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Debugging</name>
					<packageName></packageName>
					<script>--Adds debugging functionality 

function demonnic:Debug(category,debugData)
   if category then
      if table.contains(demonnic.debug.categories, category) then
         if type(debugData) == "table" then
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt;")
            display(debugData)
         elseif type(debugData) == "string" or type(debugData) == "number" then
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt; " .. debugData .. "\n" )
         else
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt; " .. tostring(debugData) .. "\n" )
         end
      end
   else
      if type(debugData) == "table" then
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt;")
         display(debugData)
      elseif type(debugData) == "string" or type(debugData) == "number" then
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt; " .. debugData)
      else
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt; " .. tostring(debugData))
      end
   end
end

function demonnic:printDebug(category, debugData)
   if not demonnic.debug.active then return end
   demonnic:Debug(category, debugData)
end

function demonnic:toggleDebug()
   if demonnic.debug.active then demonnic.debug.active = nil
   else demonnic.debug.active = true
   end
   demonnic:echo("Debugging is currently " .. (( demonnic.debug.active and "&lt;green&gt;ON&lt;white&gt;") or "&lt;red&gt;OFF&lt;white&gt;"))
end

function demonnic:watchCategory( category )
   if table.contains(demonnic.debug.categories, category) then
      for i,v in ipairs(demonnic.debug.categories) do
         if v == category then
            table.remove(demonnic.debug.categories, i)
         end
      end
      demonnic:echo("No longer watching the '&lt;red&gt;"..category.."&lt;white&gt;' category.") 
   else
      table.insert(demonnic.debug.categories, category)
      demonnic:echo("Now watching the '&lt;red&gt;"..category.."&lt;white&gt;' category.")
   end
   demonnic:echo("Debugging is currently " .. (( demonnic.debug.active and "&lt;green&gt;ON&lt;white&gt;") or "&lt;red&gt;OFF&lt;white&gt;"))
end

function demonnic:listCategories()
   if #demonnic.debug.categories &gt; 0 then
      demonnic:echo("You are currently watching the following categories:\n" .. table.concat(demonnic.debug.categories,", ") )
   else
      demonnic:echo("You are not watching any debugs.")
   end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Geyser Additions</name>
					<packageName></packageName>
					<script>function Geyser.MiniConsole:clear()
   clearWindow(self.name)
end

function Geyser.MiniConsole:append()
  appendBuffer(self.name)
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Tabbed Chat</name>
				<packageName></packageName>
				<script>--Do not remove the following lines. Or change them.
demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.tabsToBlink = demonnic.chat.tabsToBlink or {}
demonnic.chat.tabs = demonnic.chat.tabs or {}
demonnic.chat.windows = demonnic.chat.windows or {}
if not demonnic.chat.config then
  cecho("&lt;red:white&gt;YOU DO NOT HAVE THE YATCO CONFIG PACKAGE IN PLACE. THINGS WILL NOT WORK AS EXPECTED\n\n")
  demonnic.chat.error = "NO CONFIG"
end</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Code</name>
					<packageName></packageName>
					<script>--[[
If the label callbacks ever decide to start taking a function which is part of a table, 0then this will change.
Or if it's modified to take actual functions. Anonymouse function clickcallback would be awfully nice.
]]

function demonnicChatSwitch(chat)
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local newr = demonnic.chat.config.activeColors.r
  local newg = demonnic.chat.config.activeColors.g
  local newb = demonnic.chat.config.activeColors.b
  local oldchat = demonnic.chat.currentTab
  if demonnic.chat.currentTab ~= chat then
    demonnic.chat.windows[oldchat]:hide()
    demonnic.chat.tabs[oldchat]:setColor(r,g,b)
    demonnic.chat.tabs[oldchat]:echo(oldchat, demonnic.chat.config.inactiveTabText, "c")
    if demonnic.chat.config.blink and demonnic.chat.tabsToBlink[chat] then
      demonnic.chat.tabsToBlink[chat] = nil
    end
    if demonnic.chat.config.blink and chat == demonnic.chat.config.Alltab then
      demonnic.chat.tabsToBlink = {}
    end
  end
  demonnic.chat.tabs[chat]:setColor(newr,newg,newb)
  demonnic.chat.tabs[chat]:echo(chat, demonnic.chat.config.activeTabText, "c")
  demonnic.chat.windows[chat]:show()
  demonnic.chat.currentTab = chat  
end

function demonnic.chat:resetUI()
  demonnic.chat.container = demonnic.chat.useContainer or Geyser.Container:new(demonnic.chat[demonnic.chat.config.location]())
  demonnic.chat.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "25px",
    name = "DemonChatTabs",
  },demonnic.chat.container)

end

function demonnic.chat:create()
  --reset the UI
  demonnic.chat:resetUI()
  --Set some variables locally to increase readability
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local winr = demonnic.chat.config.windowColors.r
  local wing = demonnic.chat.config.windowColors.g
  local winb = demonnic.chat.config.windowColors.b

  --iterate the table of channels and create some windows and tabs
  for i,tab in ipairs(demonnic.chat.config.channels) do
    demonnic.chat.tabs[tab] = Geyser.Label:new({
      name=string.format("tab%s", tab),
    }, demonnic.chat.tabBox)
    demonnic.chat.tabs[tab]:echo(tab, demonnic.chat.config.inactiveTabText, "c")
    demonnic.chat.tabs[tab]:setColor(r,g,b)
    demonnic.chat.tabs[tab]:setClickCallback("demonnicChatSwitch", tab)
    demonnic.chat.windows[tab] = Geyser.MiniConsole:new({
--      fontSize = demonnic.chat.config.fontSize,
      x = 0,
      y = 25,
      height = "100%",
      width = "100%",
      name = string.format("win%s", tab),
    }, demonnic.chat.container)
    demonnic.chat.windows[tab]:setFontSize(demonnic.chat.config.fontSize)
    demonnic.chat.windows[tab]:setColor(winr,wing,winb)
    demonnic.chat.windows[tab]:setWrap(demonnic.chat.config.width)
    demonnic.chat.windows[tab]:hide()
  end
  if demonnic.chat.config.Maptab and demonnic.chat.config.Maptab ~= "" then
    demonnic.chat.mapWindow = Geyser.Mapper:new({
      x = 0,
      y = 0,
      height = "100%",
      width = "100%",
    }, demonnic.chat.windows[demonnic.chat.config.Maptab])
    demonnic.chat.windows[demonnic.chat.config.Maptab]:hide()
  end
  local showme = demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
  demonnicChatSwitch(showme)
  --start the blink timers, if enabled
  if demonnic.chat.config.blink and not demonnic.chat.blinkTimerOn then
    demonnic.chat:blink()
  end
end

function demonnic.chat:append(chat)
  local r = demonnic.chat.config.windowColors.r
  local g = demonnic.chat.config.windowColors.g
  local b = demonnic.chat.config.windowColors.b
  selectCurrentLine()
  local ofr,ofg,ofb = getFgColor()
  local obr,obg,obb = getBgColor()
  if demonnic.chat.config.preserveBackground then
    setBgColor(r,g,b)
  end
  copy()
  if demonnic.chat.config.timestamp then
    local timestamp = getTime(true, demonnic.chat.config.timestamp)
    local tsfg = {}
    local tsbg = {}
    local colorLeader = ""
    if demonnic.chat.config.timestampCustomColor then
      if type(demonnic.chat.config.timestampFG) == "string" then
        tsfg = color_table[demonnic.chat.config.timestampFG]
      else
        tsfg = demonnic.chat.config.timestampFG
      end
      if type(demonnic.chat.config.timestampBG) == "string" then
        tsbg = color_table[demonnic.chat.config.timestampBG]
      else
        tsbg = demonnic.chat.config.timestampBG
      end
      colorLeader = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;",tsfg[1],tsfg[2],tsfg[3],tsbg[1],tsbg[2],tsbg[3])
    else
      colorLeader = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;",ofr,ofg,ofb,obr,obg,obb)
    end
    local fullstamp = string.format("%s%s",colorLeader,timestamp)
      demonnic.chat.windows[chat]:decho(fullstamp)
      demonnic.chat.windows[chat]:echo(" ")
      if demonnic.chat.config.Alltab then 
        demonnic.chat.windows[demonnic.chat.config.Alltab]:decho(fullstamp)
        demonnic.chat.windows[demonnic.chat.config.Alltab]:echo(" ")
      end
  end
  demonnic.chat.windows[chat]:append()
  if demonnic.chat.config.gag then 
    deleteLine() 
    tempLineTrigger(1,1, [[if isPrompt() then deleteLine() end]])
  end
  if demonnic.chat.config.Alltab then appendBuffer(string.format("win%s", demonnic.chat.config.Alltab)) end
  if demonnic.chat.config.blink and chat ~= demonnic.chat.currentTab then 
    if (demonnic.chat.config.Alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end



function demonnic.chat:blink()
  if demonnic.chat.blinkID then killTimer(demonnic.chat.blinkID) end
  if not demonnic.chat.config.blink then 
    demonnic.chat.blinkTimerOn = false
    return 
  end
  if not demonnic.chat.container.hidden then
    for tab,_ in pairs(demonnic.chat.tabsToBlink) do
      demonnic.chat.tabs[tab]:flash()
    end
  end
  demonnic.chat.blinkID = tempTimer(demonnic.chat.config.blinkTime, function () demonnic.chat:blink() end)
end

function demonnic.chat:topright()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=string.format("-%sc",demonnic.chat.config.width + 2),
    y=0,
    width="-15px",
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:topleft()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=0,
    y=0,
    width=string.format("%sc",demonnic.chat.config.width),
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:bottomright()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=string.format("-%sc",demonnic.chat.config.width + 2),
    y=string.format("-%sc",demonnic.chat.config.lines + 2),
    width="-15px",
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:bottomleft()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=0,
    y=string.format("-%sc",demonnic.chat.config.lines + 2),
    width=string.format("%sc",demonnic.chat.config.width),
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>demonnicOnStart</name>
					<packageName></packageName>
					<script>function demonnicOnStart()
  if demonnic.chat.use then
    demonnic.chat:create()
  end
end</script>
					<eventHandlerList>
						<string>sysLoadEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>echo functions</name>
					<packageName></packageName>
					<script>
function demonnic.chat:cecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  cecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    cecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:decho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  decho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    decho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:hecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  hecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    hecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end


function demonnic.chat:echo(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  echo(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    echo(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>demonnicOnInstall</name>
					<packageName></packageName>
					<script>function demonnicOnInstall(_, package)
  if package:find("YATCO") then
  	demonnicOnStart()
  end
end</script>
					<eventHandlerList>
						<string>sysInstall</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
