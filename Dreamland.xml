<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Dreamland UI</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>prompt trigger</name>
				<script>dhb.stats.health = tonumber(multimatches[2][2])
dhb.stats.maxhealth = tonumber(multimatches[2][3])
dhb.stats.mana = tonumber(multimatches[2][4])
dhb.stats.maxmana = tonumber(multimatches[2][5])
dhb.stats.steps = tonumber(multimatches[2][6])
dhb.stats.maxsteps = tonumber(multimatches[2][7])
dhb.stats.mypercent, dhb.stats.targetpercent = nil, nil</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>&lt;</string>
					<string>&lt;(\d+)/(\d+)зд (\d+)/(\d+)ман (\d+)/(\d+)шг (\d+)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>combat</name>
					<script>dhb.stats.mypercent = tonumber(matches[2])
dhb.stats.targetpercent = tonumber(matches[3])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>\[(\d+)%:(\d+)%\]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Raise prompt event</name>
					<script>raiseEvent("dhb on prompt")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>return true</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>4</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Dreamland mapper script</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Can't go there</name>
				<script>raiseEvent("onMoveFail")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Извини, но ты не можешь туда идти.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="yes" isColorTriggerBg="yes">
				<name>Room</name>
				<script>local matchedline, currentline = matches[1], line
if matchedline ~= currentline then return end

map.prompt.room = currentline</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#ffffff</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>FG15BG2</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>6</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Exits</name>
				<script>map.prompt.exits = multimatches[2][2]
raiseEvent("onNewRoom")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>[Выходы:</string>
					<string>\[Выходы: (.+)\]$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Prompt</name>
				<script>raiseEvent("onPrompt")

-- safety check in case we don't capture the room title next time but we do get the exits and prompt
map.prompt.room = nil</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>&lt;</string>
					<string>&lt;\d+/\d+зд</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Random movement</name>
				<script>raiseEvent("onRandomMove")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Ты убегаешь с поля битвы!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Can't see</name>
				<script>raiseEvent("onVisionFail")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Здесь слишком темно ... </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Dreamland tabbed chat</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>OOC</name>
				<script>demonnic.chat:append("OOC")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>[ooc]</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Auction</name>
				<script>demonnic.chat:append("Auction")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string> AUCTION:</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>2</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Dreamland</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Stop speedwalking</name>
				<script>dhb.stopwalking()</script>
				<command></command>
				<packageName></packageName>
				<regex>^mstop$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Dreamland UI</name>
			<packageName></packageName>
			<script> -- initial UI by Vadi
 
 dhb = dhb or {
  stats = {
    health = 0,
    maxhealth = 10,
    mana = 0,
    maxmana = 100,
    steps = 0,
    maxsteps = 100
	},
	ui = {},
	version = 0.3
}</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>UI</name>
				<packageName></packageName>
				<script>local function addstyling(gauge, color)
  gauge:setStyleSheet([[
    border-width: 1px; border-style: solid; border-radius: 5px; background-color: ]]..color)
end

dhb.bottompanel = Geyser.HBox:new({
  name="bottompanel",
  x=0, y="-3%",
  width="100%", height="3%",
})
setBorderBottom(dhb.bottompanel:get_height())

dhb.healthbox = Geyser.VBox:new({name="dhb.healthbox"}, dhb.bottompanel)
dhb.healthbar = Geyser.Gauge:new({name="healthbar"}, dhb.healthbox)
addstyling(dhb.healthbar.front, "#BB0000")
addstyling(dhb.healthbar.back, "#630000")

dhb.enemyhealthbar = Geyser.Gauge:new({name="enemyhealthbar"}, dhb.healthbox)
addstyling(dhb.enemyhealthbar.front, "#990000")
addstyling(dhb.enemyhealthbar.back, "#420000")

dhb.manabar = Geyser.Gauge:new({name="manabar"}, dhb.bottompanel)
addstyling(dhb.manabar.front, "#3465A4")
addstyling(dhb.manabar.back, "#182f4c")

dhb.stepsbar = Geyser.Gauge:new({name="stepsbar"}, dhb.bottompanel)
addstyling(dhb.stepsbar.front, "#055705")
addstyling(dhb.stepsbar.back, "#0aab0a")

function dhb.ui.updatestats()
  dhb.healthbar:setValue(dhb.stats.health, dhb.stats.maxhealth)
  dhb.healthbar:setText(string.format(
	  "&lt;center&gt;Здоровье %d/%d&lt;/center&gt;", dhb.stats.health, dhb.stats.maxhealth))
		
  dhb.manabar:setValue(dhb.stats.mana, dhb.stats.maxmana)
  dhb.manabar:setText(string.format(
	  "&lt;center&gt;Mana %d/%d&lt;/center&gt;", dhb.stats.mana, dhb.stats.maxmana))
		
  dhb.stepsbar:setValue(dhb.stats.steps, dhb.stats.maxsteps)
  dhb.stepsbar:setText(string.format(
	  "&lt;center&gt;Шаги %d/%d&lt;/center&gt;", dhb.stats.steps, dhb.stats.maxsteps))
end

function dhb.ui.updatecombat()
  if not dhb.stats.targetpercent then
	  dhb.enemyhealthbar:hide()
		dhb.enemyhealthbar.v_stretch_factor = 0
		dhb.healthbar.v_stretch_factor = 2
		dhb.healthbox:reposition()
		return
	end
	
	dhb.healthbar.v_stretch_factor = 1
	dhb.enemyhealthbar.v_stretch_factor = 1
	dhb.enemyhealthbar:setValue(dhb.stats.targetpercent, 100)
	dhb.enemyhealthbar:show()
	dhb.healthbox:reposition()
end


registerAnonymousEventHandler("dhb on prompt", "dhb.ui.updatestats")
registerAnonymousEventHandler("dhb on prompt", "dhb.ui.updatecombat")

raiseEvent("dhb on prompt")</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Dreamland mapper script</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Simple Window Manager</name>
				<packageName></packageName>
				<script>-- Window Manager Script --
--  Zachary Hiland
--  10/22/2016
--  v2.00c
--
--  Functions Details
--
--      windowManager.create(name, type, x, y, width, height, origin, [font_size]) or windowManager.add(info_table)
--      creates a window and adds it to the windowManager
--
--      info_table must have a valid entry for each argument, by the same name, as in the normal function call
--      name - name of already created window (label, miniConsole, gauge, mapper, menu, or autowrap)
--          Note: for a mapper window, use any name you like, so long as it isn't the name of some other object
--      type - identify the type of window, must be label, miniConsole, gauge, mapper, or menu
--      x - distance horizontally from the origin corner
--      y - distance vertically from the origin corner
--      width - width of window
--      height - height of window
--      origin - corner to act as origin for this window, must be topleft, topright, bottomleft, or bottomright
--      font_size - only used for autowrap windows, will be automatically set as the font size for the created window
--
--      note: all measurements should be numbers, or strings with values measured in percent or pixels (or unlabeled)
--          if a measurement contains both percent and pixel values (or multiple values of the same type), they should be separated
--          by a "+" symbol. Example: "25% + 50px + 16"
--      important: no negative numbers
--
--      windowManager.add(name, type, x, y, width, height, origin, font_size) or windowManager.create(info_table)
--      adds an already created window to the windowManager, uses the exact same arguments as those in the "create" function
--
--      windowManager.remove(name)
--      removes a window from the windowManager
--
--      windowManager.move(name, x, y)
--      moves a window with the windowManager
--
--      windowManager.resize(name, width, height)
--      resizes a window with the windowManager
--
--      windowManager.relocate(name, origin)
--      changes the corner acting as the origin for a window in the windowManager
--
--      windowManager.show(name)
--      shows a window that is managed by windowManager (you can also use showWindow or showGauge functions)
--          Note: this is only really important for a mapper window
--
--      windowManager.hide(name)
--      hides a window that is managed by windowManager (you can also use hideWindow or hideGauge functions)
--          Note: this is only really important for a mapper window
--
--      windowManager.getValue(name, value)
--      returns the calculated size or position values, or the origin, for a window in the windowManager
--
--      windowManager.math(value1, value2, operation)
--      allows addition and subtraction of measurements with each other,
--      and multiplication and division of a measurement by a normal number
--
--      windowManager.simplify(measurement)
--      returns a simplified version of a measurement (all percent and pixel values are combined together)
--
--      windowManager.refresh(name)
--      sets the size and location of a window in the windowManager using previously set values
--      note: generally this function does not need to be called
--
--      windowManager.refreshAll()
--      note: this function is called automatically when a sysWindowResizeEvent event occurs,
--          and generally does not need to be called manually
--
--      windowManager.createBuffer(name)
--      creates a buffer to be used with an autowrap window, only needed if miniconsole added manually to windowManager
--
--      windowManager.append(name)
--      appends text to an autowrap window, works just like appendBuffer()
--
--      windowManager.echo(name, text)
--      echoes text to an autowrap window. cecho, decho, and hecho are also available.
--
--      windowManager.clear(name)
--      clears an autowrap window.
--
--      windowManager.setFontSize(name, font_size)
--      sets the font size for an autowrap window.

windowManager = windowManager or {}
windowManager.list = windowManager.list or {}

local function calcScaledNum(scale,num)
    scale_table = string.split(scale," %+ ")
    if #scale_table &gt; 2 then
        scale = windowManager.simplify(scale)
        scale_table = string.split(scale," %+ ")
    end
    scale = 0
    if #scale_table == 2 then
        scale = string.cut(scale_table[1],#scale_table[1] - 1) * num / 100
        scale = scale + string.gsub(scale_table[2],"px","")
    elseif string.find(scale_table[1],"%%") then
        scale = string.cut(scale_table[1],#scale_table[1] - 1) * num / 100
    else
        scale = string.gsub(scale_table[1],"px","")
    end
    scale = math.floor(scale + 0.5)
    return scale
end

local function rewrap_window(name)
    local info = windowManager.list[name]
    local buffer = name .. "_windowManager_buffer"
    local wrap = math.floor(windowManager.getValue(name,"width") / calcFontSize(info.font))
    local line, moved
    setWindowWrap(name,wrap)
    clearWindow(name)
    line = 0
    moved = moveCursor(buffer,1,line)
    while moved do
        selectCurrentLine(buffer)
        copy(buffer)
        line = line + 1
        moved = moveCursor(buffer,1,line)
        appendBuffer(name)
    end
end

function windowManager.simplify(measure)
    measure = string.gsub(measure,"%s*-%s*([%d%%]+)"," + -%1")
    measure = string.gsub(measure,"%-%-","")
    measure = string.gsub(measure,"%+%s*%+","+")
    measure = string.gsub(measure,"^%s*%+","")
    local measure_table = string.split(measure,"+")
    local percent, pixel = 0,0
    for k,v in ipairs(measure_table) do
        v = string.trim(v)
        if string.find(v,"%%") then
            v = string.gsub(v,"%%","")
            if not tonumber(v) then display(measure) end
            percent = percent + v
        elseif v ~= "" then
            v = string.gsub(v,"px","")
            if not tonumber(v) then display(measure) end
            pixel = pixel + v
        end
    end
    percent = math.floor(1000 * percent + .5) / 1000
    pixel = math.floor(1000 * pixel + .5) / 1000
    if percent == 0 then
        measure = pixel .. "px"
    elseif pixel == 0 then
        measure = percent .. "%"
    else
        measure = percent .. "% + " .. pixel .. "px"
    end
    return measure
end

function windowManager.math(measure,num,op)
    if not table.contains({"multiply","divide", "add", "subtract"},op) then
        error("windowManager.math: bad argument #3 \"operation\", must be add, subtract, multiply or divide",2)
    end
    if op == "divide" or op == "multiply" then
        if string.find(num,"%%") then
            num = string.gsub(num,"%%","") / 100
        end
        if not tonumber(num) then
            error("windowManager.math: bad argument #2 \"num\", must be a number",2)
        end
        num = tonumber(num)
        measure = string.gsub(measure,"%s*-%s*([%d%%]+)"," + -%1")
        measure = string.gsub(measure,"%+%s*%+","+")
        measure = string.gsub(measure,"^%s*%+","")
        local measure_table = string.split(measure,"+")
        if op == "divide" then num = 1 / num end
        for k,v in ipairs(measure_table) do
            v = string.trim(v)
            v = (string.gsub(v,"([%d%.]+).*","%1") * num) .. string.gsub(v,".*[%d%.]+(.*)","%1")
            measure_table[k] = v
        end
        measure = table.concat(measure_table," + ")
    else
        if op == "subtract" then
            num = windowManager.math(num,"-1","multiply")
        end
        measure = measure .. " + " .. num
        measure = string.gsub(measure,"([^%s%+%-]+)%s*-%s*([%d%.%-]+)","%1 + -%2")
    end
    return windowManager.simplify(measure)
end

function windowManager.create(name, window_type, ...)
    local tbl = {}
    local is_table = false
    if type(name) == "table" then
        table.update(tble,name)
        name = tbl.name
        window_type = tbl.type
        is_table = true
    end
    if type(window_type) ~= "string" then
        error("windowManager.create: bad argument #2 \"type\", must be string.",2)
    end
    window_type = string.lower(window_type)
    if not table.contains({"label","miniconsole","gauge","mapper","menu","autowrap"},window_type) then
        error("windowManager.create: invalid type",2)
    end
    if window_type == "label" then
        createLabel(name, 0,0,0,0,1)
    elseif window_type == "miniconsole" then
        createMiniConsole(name,0,0,0,0)
    elseif window_type == "gauge" then
        createGauge(name,0,0,0,0)
    elseif window_type == "menu" then
        createMenu(name,0,0,0,0)
    elseif window_type == "autowrap" then
        createMiniConsole(name,0,0,0,0)
        createBuffer(name .. "_windowManager_buffer")
        setWindowWrap(name .. "_windowManager_buffer",1000)
    end
    if is_table then
        return windowManager.add(tbl)
    else
        return windowManager.add(name, window_type, ...)
    end
end

function windowManager.makeBuffer(name)
    createBuffer(name .. "_windowManager_buffer")
    setWindowWrap(name .. "_windowManager_buffer",1000)
end

function windowManager.add(name, window_type, x, y, w, h, origin, font)
    local tbl = {}
    if type(name) == "table" then
        tbl = table.update(tbl,name)
        name = tbl.name
        x = tbl.x
        y = tbl.y
        w = tbl.width
        h = tbl.height
        origin = tbl.origin
        window_type = tbl.type
        font = tbl.font_size
        tbl = {}
    end
    font = font or 10
    if not name then
        error("windowManager.add: bad argument #1 \"name\".",2)
    end
    windowManager.list[name] = nil
    if type(window_type) ~= "string" then
        error("windowManager.add: bad argument #2 \"type\", must be string.",2)
    end
    window_type = string.lower(window_type)
    if not table.contains({"label","miniconsole","gauge","mapper","menu","autowrap"},window_type) then
        error("windowManager.add: invalid type",2)
    end
    if not (x and y and w and h) then
        error("windowManager.add: must have x, y, width, and height.",2)
    end
    origin = origin or "topleft"
    origin = string.lower(origin)
    if not table.contains({"topleft","topright","bottomleft","bottomright"},origin) then
        error("windowManager.add: bad argument #7 \"origin\".",2)
    end
    x = windowManager.simplify(x)
    y = windowManager.simplify(y)
    w = windowManager.simplify(w)
    h = windowManager.simplify(h)
    tbl = {
        type = window_type,
        x = x, y = y, h = h, w = w,
        origin = origin}
    if window_type == "autowrap" then
        tbl.font = font
        setMiniConsoleFontSize(name, font)
    end
    windowManager.list[name] = tbl
    windowManager.refresh(name)
end

function windowManager.remove(name)
    windowManager.list[name] = nil
end

function windowManager.refresh(name, main_w, main_h)
    local info = windowManager.list[name]
    if not info then error("windowManager.refresh: no such window.",2) end
    local x,y,w,h,origin,win_type = info.x, info.y, info.w, info.h, info.origin, info.type
    if not (main_w and main_h) then
        main_w, main_h = getMainWindowSize()
    end
    w = calcScaledNum(w,main_w)
    x = calcScaledNum(x,main_w)
    h = calcScaledNum(h,main_h)
    y = calcScaledNum(y,main_h)
    if string.find(origin,"right") then
        x = main_w - x - w
    end
    if string.find(origin,"bottom") then
        y = main_h - y - h
    end
    if win_type == "gauge" then
        moveGauge(name,x,y)
        resizeGauge(name,w,h)
    elseif win_type == "mapper" then
        if not info.hide then
            createMapper(x,y,w,h)
        end
    elseif win_type == "menu" then
        moveMenu(name,x,y)
        resizeMenu(name,w,h)
    else
        moveWindow(name,x,y)
        resizeWindow(name,w,h)
        if win_type == "autowrap" then
            rewrap_window(name)
        end
    end
end

function windowManager.resize(name, w, h)
    local info = windowManager.list[name]
    if not info then error("windowManager.resize: no such window.",2) end
    if not (w and h) then error("windowManager.resize: must have both width and height.",2) end
    w = windowManager.simplify(w)
    h = windowManager.simplify(h)
    windowManager.list[name].w = w
    windowManager.list[name].h = h
    windowManager.refresh(name)
end

function windowManager.move(name, x, y)
    local info = windowManager.list[name]
    if not info then error("windowManager.move: no such window.",2) end
    if not (x and y) then error("windowManager.move: must have both x and y.",2) end
    x = windowManager.simplify(x)
    y = windowManager.simplify(y)
    windowManager.list[name].x = x
    windowManager.list[name].y = y
    windowManager.refresh(name)
end

function windowManager.relocate(name, origin)
    local info = windowManager.list[name]
    if not info then error("windowManager.relocate: no such window.",2) end
    origin = origin or "topleft"
    origin = string.lower(origin)
    if not table.contains({"topleft","topright","bottomleft","bottomright"},origin) then
        error("windowManager.relocate: bad argument #2 \"origin\".",2)
    end
    windowManager.list[name].origin = origin
    windowManager.refresh(name)
end

function windowManager.hide(name)
    local info = windowManager.list[name]
    if not info then error("windowManager.hide: no such window.",2) end
    local info = windowManager.list[name]
    if info.type == "gauge" then
        hideGauge(name)
    elseif info.type == "mapper" then
        windowManager.list[name].hide = true
        createMapper(0,0,0,0)
    elseif info.type == "menu" then
        hideMenu(name)
    else
        hideWindow(name)
    end
end

function windowManager.show(name)
    local info = windowManager.list[name]
    if not info then error("windowManager.show: no such window.",2) end
    local info = windowManager.list[name]
    if info.type == "gauge" then
        showGauge(name)
    elseif info.type == "mapper" then
        windowManager.list[name].hide = false
        windowManager.refresh(name)
    elseif info.type == "menu" then
        showMenu(name)
    else
        showWindow(name)
    end
end

function windowManager.setFontSize(name, font_size)
    local info = windowManager.list[name]
    if not info then error("windowManager.setFontSize: no such window.",2) end
    windowManager.list[name].font = font_size
    setMiniConsoleFontSize(name, font_size)
    windowManager.refresh(name)
end

function windowManager.clear(name)
    local info = windowManager.list[name]
    if not info then error("windowManager.clear: no such window.",2) end
    clearWindow(name)
    clearWindow(name .. "_windowManager_buffer")
end

function windowManager.append(name)
    local info = windowManager.list[name]
    if not info then error("windowManager.append: no such window.",2) end
    appendBuffer(name)
    appendBuffer(name .. "_windowManager_buffer")
end

function windowManager.echo(name, text)
    local info = windowManager.list[name]
    if not info then error("windowManager.echo: no such window.",2) end
    echo(name, text)
    echo(name .. "_windowManager_buffer", text)
end

function windowManager.cecho(name, text)
    local info = windowManager.list[name]
    if not info then error("windowManager.cecho: no such window.",2) end
    cecho(name, text)
    cecho(name .. "_windowManager_buffer", text)
end

function windowManager.hecho(name, text)
    local info = windowManager.list[name]
    if not info then error("windowManager.hecho: no such window.",2) end
    hecho(name, text)
    hecho(name .. "_windowManager_buffer", text)
end

function windowManager.decho(name, text)
    local info = windowManager.list[name]
    if not info then error("windowManager.decho: no such window.",2) end
    decho(name, text)
    decho(name .. "_windowManager_buffer", text)
end

function windowManager.getValue(name, value)
    local info = windowManager.list[name]
    if not info then error("windowManager.getValue: no such window.",2) end
    if not table.contains({"x","y","width","height","w","h","origin"},value) then
        error("windowManager.getValue: no such value.",2)
    end
    local sys_w, sys_h = getMainWindowSize()
    if value == "width" then value = "w" end
    if value == "height" then value = "h" end
    local tmp = windowManager.list[name][value]
    if value == "w" or value == "x" then
        tmp = calcScaledNum(tmp,sys_w)
    elseif value == "h" or value == "y" then
        tmp = calcScaledNum(tmp,sys_h)
    end
    return tmp
end

function windowManager.refreshAll()
    local main_w, main_h = getMainWindowSize()
    for k,v in pairs(windowManager.list) do
        windowManager.refresh(k, main_w, main_h)
    end
end

registerAnonymousEventHandler("sysWindowResizeEvent", "windowManager.refreshAll")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Generic Mapper Script config</name>
				<packageName></packageName>
				<script>map = map or {}
map.configs = map.configs or {}

map.configs.show_map = false</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Generic Mapper Script</name>
				<packageName></packageName>
				<script>-- Jor'Mox's Generic Map Script
-- 8/30/2018
-- v1.17
--

map = map or {}

map.help = [[
    Jor'Mox's Generic Map Script

    This script allows for semi-automatic mapping using just room names and exits. It is
    a good idea to know the general layout of the area you are trying to map before
    turning on mapping with this script, so as to minimize how much you need to move
    things around to make it look how you want it to. The script will automatically
    stretch out a map to make space for a room if it would overlap with another one, but
    it is important to make sure that things line up properly, or you will have inaccurate
    maps with duplicate sections in them.

    It is up to YOU to create triggers that appropriately raise the following events, and
    gather the necessary information. The way in which such things are displayed varies
    dramatically from game to game, so any set of triggers for one game will likely not
    work for the next.

    Important Events for Proper Mapping
        onMoveFail - raise this event to indicate that you attempted to move, but no move
            was made
        onVisionFail - raise this event to indicate that you moved successfully, but are
            unable to gather some or all of the necessary info about the room
        onRandomMove - raise this event to indicate that you moved, but do not know what
            direction you moved in
        onNewRoom - raise this event to indicate that a room has been detected, typically
            after moving or looking to see the room you are currently in
        onPrompt - raise this event to indicate a prompt has been detected, room name and
            exits must be stored in map.prompt.room and map.prompt.exits before raising
            this event
        onForcedMove - raise this event to indicate that you have been moved without
            entering a command, but you know the direction you went. pass the relevant
            direction as the first argument. if this movement needs to preempt other
            movement commands in the queue (often the case), then pass "true" as a string
            as the second argument

    Important Commands (Aliases) for Proper Mapping

        Fundamental Aliases
        start mapping &lt;optional area name&gt; - use this command to start adding new content
            to the map, area name is required if there are no rooms in the map
        stop mapping - use this command to stop mapping
        save map - saves the map to a file (map.dat, located in the profile folder), this
            is generally only needed to share the map with someone else, or to act as a
            backup in case something happens to the map that Mudlet maintains for your
            profile
        load map &lt;optional 'local'&gt; - loads the map from the location specified in the
            download_path, or from the local copy
        export area &lt;area name&gt; - exports a file to the profile folder with data for the
            named area
        import area &lt;area name&gt; - imports area data from a file created with export area,
            must be located in profile folder


        Mapping Aliases
        map mode &lt;simple, normal, or complex&gt; - sets the mapping mode, determining what
            exits are set automatically as you move around
        set area &lt;area name&gt; - move the current room into the named area, area will be
            created if it does not currently exist
        shift &lt;direction&gt; - use this command to move the room you are currently in around
            on the map
        merge rooms - use this command to combine the room you are in with any other rooms
            in the same location and with the same name
        clear moves - use this command to clear the move queue after you attempt a move
            that doesn't succeed, but for which there is no trigger indicating this with
            the onMoveFail event
        add door &lt;direction&gt; &lt;optional none, open, closed, locked&gt; &lt;optional yes, no&gt; -
            adds a door in the given direction, defaulting to closed (use none to remove
            a door), and defaulting 'no' for one-way status
        add portal &lt;entry command&gt; - adds a portal that uses the given command for entry
            to force this command to create a new room, rather than linking to an existing
            one, put -f before the entry command, like this: add portal -f enter portal
        set exit &lt;direction&gt; &lt;roomID&gt; - sets the given direction to connect, one way,
            to the room with the specified roomID, used for very complex areas
            to set the destination room for a portal, put -p before the portal entry command
            like this: set exit -p enter portal 1124

        Normal User Aliases
        find me - use this command to search the entire map to try to locate you based on
            room name and exits, typically not necessary, as this will be done anyway if
            a person moves and their location is unknown
        find path &lt;room name&gt; OR &lt;room name&gt; ; &lt;area name&gt; - used to find a walking path
            to a room with the given name, in the given area if specified
        set character &lt;name&gt; - sets the current character name (stored as map.character)
        set recall - sets the current room as the recall room for the current character

    Important Information Regarding Speedwalking

        The existing doSpeedWalk function (which is located at the bottom of the script,
        just above the event handler function) currently only displays a list of moves
        to make to get to the target room. This function should be modified to implement
        speedwalking in your game. For this purpose, a table of roomIDs is generated and
        and stored in speedWalkPath, and a matching table of directions is stored in
        speedWalkDir. You can check for doors with a roomID and a direction using the
        check_doors function in the following manner: check_doors(roomID,dir) or
        check_doors(roomID,tbl_of_dirs). It will return false if a door is not present,
        or a table of directions and door status codes, like what you would get using the
        getDoors function, but only for the exit(s) specified.

        For the sake of convenience, whenever the mapper moves to a new room, it raises the
        "onMoveMap" event and passes the new roomID with the event, which may be helpful
        in implementing more advanced scripts and functions that rely on map information.
]]

map.recall = map.recall or {}
map.character = map.character or ""
map.prompt = map.prompt or {}

local oldstring = string
local string = utf8
string.format = oldstring.format
string.trim = oldstring.trim
string.starts = oldstring.starts
string.split = oldstring.split

map.configs = {
    mode = "normal", -- can be simple, normal, or complex
    show_map = true,
    x = 16,
    y = 0,
    w = "30%",
    h = "40%",
    origin = "topright",
    download_path = "",
    stretch_map = true,
    search_on_look = true,
    custom_exits = {},  -- format: short_exit = {long_exit, reverse_exit, x_dif, y_dif, z_dif}
                        -- ex: { us = {"upsouth", "downnorth", 0, -1, 1}, dn = {"downnorth", "upsouth", 0, 1, -1} }
}

local function make_aliases()
    map.aliases = map.aliases or {}
    local id
    local tbl = {
        ["Start Mapping Alias"] = {[[^start mapping(?: (.*))?$]], [[map.start_mapping(matches[2])]]},
        ["Stop Mapping Alias"] = {[[^stop mapping$]], [[map.stop_mapping()]]},
        ["Save Map Alias"] = {[[^save map$]], [[saveMap(getMudletHomeDir() .. "/map.dat")]]},
        ["Load Map Alias"] = {[[^load map(?: (local))?$]], [[map.load_map(matches[2])]]},
        ["Export Map Area Alias"] = {[[^export area (.*)]],[[map.export_area(matches[2])]]},
        ["Import Map Area Alias"] = {[[^import area (.*)]],[[map.import_area(matches[2])]]},

        ["Set Room Area Alias"] = {[[^set area (.*)$]], [[map.set_area(matches[2])]]},
        ["Set Map Mode Alias"] = {[[^map mode (\w+)$]],[[map.set_mode(matches[2])]]},
        ["Shift Room Alias"] = {[[^shift (.*)$]], [[map.shift_room(matches[2])]]},
        ["Merge Rooms Alias"] = {[[^merge rooms$]], [[map.merge_rooms()]]},
        ["Add Door Alias"] = {[[^add door (\w+)(?: (none|open|closed|locked)(?: (yes|no))?)?$]],[[map.set_door(matches[2],matches[3],matches[4])]]},
        ["Add Portal Alias"] = {[[^add portal (.*)$]],[[map.set_portal(matches[2])]]},
        ["Set Room Exit Alias"] = {[[^set exit (.+) (\d+)]],[[map.set_exit(matches[2],matches[3])]]},
        ["Clear Moves Alias"] = {[[^clear moves$]], [[map.clear_moves()]]},

        ["Find Me Alias"] = {[[^find me$]], [[map.find_me()]]},
        ["Find Path Alias"] = {[[find path ([^;]+)(?:\s*;\s*(.+))?]],[[map.find_path(matches[2],matches[3])]]},
        ["Set Recall Alias"] = {[[^set recall$]],[[map.set_recall()]]},
        ["Set Character Alias"] = {[[^set character (.*)$]],[[map.character = matches[2] ]]},
    }
    for k,v in pairs(tbl) do
        if map.aliases[k] and exists(map.aliases[k],"alias") ~= 0 then
            killAlias(map.aliases[k])
        end
        id = tempAlias(v[1],v[2])
        map.aliases[k] = id
    end
end

local function config()
    local configs = map.configs
    map_mode = configs.mode
    --print(configs.x,configs.y,configs.w,configs.h,configs.origin)
    if configs.show_map then
        windowManager.add("mini_map","mapper",configs.x,configs.y,configs.w,configs.h,configs.origin)
        windowManager.show("mini_map")
    end

    -- incorporate custom exits
    for k,v in pairs(map.configs.custom_exits) do
        exitmap[k] = v[1]
        reverse_dirs[v[1]] = v[2]
        short[v[1]] = k
        local count = #coordmap
        coordmap[count] = {v[3],v[4],v[5]}
        stubmap[count] = v[1]
        stubmap[v[1]] = count
    end

    make_aliases()
end

local move_queue = {}
local prevRoom, prevName, prevExits
local currentRoom, currentName, currentExits, currentArea
local mapping, map_mode, downloading
local find_portal, vision_fail, room_detected, random_move, force_portal

local exitmap = {
    n = 'north',    ne = 'northeast',   nw = 'northwest',   e = 'east',
    w = 'west',     s = 'south',        se = 'southeast',   sw = 'southwest',
    u = 'up',       d = 'down',         ["in"] = 'in',      out = 'out',
}

local short = {}
for k,v in pairs(exitmap) do
    short[v] = k
end

local stubmap = {
    north = 1,      northeast = 2,      northwest = 3,      east = 4,
    west = 5,       south = 6,          southeast = 7,      southwest = 8,
    up = 9,         down = 10,          ["in"] = 11,        out = 12,
    [1] = "north",  [2] = "northeast",  [3] = "northwest",  [4] = "east",
    [5] = "west",   [6] = "south",      [7] = "southeast",  [8] = "southwest",
    [9] = "up",     [10] = "down",      [11] = "in",        [12] = "out",
}

local coordmap = {
    [1] = {0,1,0},      [2] = {1,1,0},      [3] = {-1,1,0},     [4] = {1,0,0},
    [5] = {-1,0,0},     [6] = {0,-1,0},     [7] = {1,-1,0},     [8] = {-1,-1,0},
    [9] = {0,0,1},      [10] = {0,0,-1},    [11] = {0,0,0},     [12] = {0,0,0},
}

local reverse_dirs = {
    north = "south", south = "north", west = "east", east = "west", up = "down",
    down = "up", northwest = "southeast", northeast = "southwest", southwest = "northeast",
    southeast = "northwest", ["in"] = "out", out = "in",
}

local function set_room(roomID)
    -- moves the map to the new room
    if currentRoom ~= roomID then
        prevRoom = currentRoom
        currentRoom = roomID
    end
    if getRoomName(currentRoom) ~= currentName then
        prevName = currentName
        prevExits = currentExits
        currentName = getRoomName(currentRoom)
        currentExits = getRoomExits(currentRoom)
        -- check handling of custom exits here
        for i = 13,#stubmap do
            currentExits[stubmap[i]] = tonumber(getRoomUserData(currentRoom,"exit " .. stubmap[i]))
        end
    end
    currentArea = getRoomArea(currentRoom)
    centerview(currentRoom)
    raiseEvent("onMoveMap", currentRoom)
end

local function add_door(roomID, dir, status)
    -- create or remove a door in the designated direction
    -- consider options for adding pickable and passable information
    dir = exitmap[dir] or dir
    if not table.contains(exitmap,dir) then error("Add Door: invalid direction.",2) end
    status = assert(table.index_of({"none","open","closed","locked"},status),"Add Door: Invald status, must be none, open, closed, or locked") - 1
    local exits = getRoomExits(roomID)
    -- check handling of custom exits here
    if not exits[dir] then
        setExitStub(roomID,stubmap[dir],true)
    end
    -- check handling of custom exits here
    if not table.contains({'u','d'},short[dir]) then
        setDoor(roomID,short[dir],status)
    else
        setDoor(roomID,dir,status)
    end
end

local function check_doors(roomID,exits)
    -- looks to see if there are doors in designated directions
    -- used for room comparison, can also be used for pathing purposes
    if type(exits) == "string" then exits = {exits} end
    local statuses = {}
    local doors = getDoors(roomID)
    local dir
    for k,v in pairs(exits) do
        dir = short[k] or short[v]
                if table.contains({'u','d'},dir) then
                    dir = exitmap[dir]
                end
        if not doors[dir] or doors[dir] == 0 then
            return false
        else
            statuses[dir] = doors[dir]
        end
    end
    return statuses
end

local function find_room(name, area)
    -- looks for rooms with a particular name, and if given, in a specific area
    local rooms = searchRoom(name)
    if type(area) == "string" then
        local areas = getAreaTable() or {}
        for k,v in pairs(areas) do
            if string.lower(k) == string.lower(area) then
                area = v
                break
            end
        end
        area = areas[area] or nil
    end
    for k,v in pairs(rooms) do
        if string.lower(v) ~= string.lower(name) then
            rooms[k] = nil
        elseif area and getRoomArea(k) ~= area then
            rooms[k] = nil
        end
    end
    return rooms
end

local function getRoomStubs(roomID)
    -- turns stub info into table similar to exit table
    local stubs = getExitStubs(roomID)
    if type(stubs) ~= "table" then stubs = {} end
    -- check handling of custom exits here
    local tmp
    for i = 13,#stubmap do
        tmp = tonumber(getRoomUserData(roomID,"stub"..stubmap[i]))
        if tmp then table.insert(stubs,tmp) end
    end

    local exits = {}
    for k,v in pairs(stubs) do
        exits[stubmap[v]] = 0
    end
    return exits
end

local function connect_rooms(ID1, ID2, dir1, dir2, no_check)
    -- makes a connection between rooms
    -- can make backwards connection without a check
    local match = false
    if not ID1 and ID2 and dir1 then error("Connect Rooms: Missing Required Arguments.",2) end
    dir2 = dir2 or reverse_dirs[dir1]
    -- check handling of custom exits here
    if stubmap[dir1] &lt;= 12 then
        setExit(ID1,ID2,stubmap[dir1])
    else
        setRoomUserData(ID1,"exit " .. dir1,ID2)
    end
    if stubmap[dir1] &gt; 13 then
        -- check handling of custom exits here
        setRoomUserData(ID1,"stub"..dir1,"")
    end
    if map_mode ~= "complex" then
        local stubs = getRoomStubs(ID2)
        if stubs[dir2] then match = true end
        if (match or no_check) then
            -- check handling of custom exits here
            if stubmap[dir1] &lt;= 12 then
                setExit(ID2,ID1,stubmap[dir2])
            else
                setRoomUserData(ID2,"exit " .. dir2,ID1)
            end
            if stubmap[dir2] &gt; 13 then
                -- check handling of custom exits here
                setRoomUserData(ID2,"stub"..dir2,"")
            end
        end
    end
end

local function check_room(roomID, name, exits)
    -- check to see if room name and exits match expecations
    if not roomID then error("Check Room Error: No ID",2) end
    if name ~= getRoomName(roomID) then return false end
    local t_exits = table.union(getRoomExits(roomID),getRoomStubs(roomID))
    -- check handling of custom exits here
    for i = 13,#stubmap do
        t_exits[stubmap[i]] = tonumber(getRoomUserData(roomID,"exit " .. stubmap[i]))
    end
    for k,v in ipairs(exits) do
        if short[v] and not table.contains(t_exits,v) then return false end
        t_exits[v] = nil
    end
    return table.is_empty(t_exits) or check_doors(roomID,t_exits)
end

local function stretch_map(dir,x,y,z)
    -- stretches a map to make room for just added room that would overlap with existing room
    local dx,dy,dz
    for k,v in pairs(getAreaRooms(currentArea)) do
        if v ~= currentRoom then
            dx,dy,dz = getRoomCoordinates(v)
            if dx &gt;= x and string.find(dir,"east") then
                dx = dx + 1
            elseif dx &lt;= x and string.find(dir,"west") then
                dx = dx - 1
            end
            if dy &gt;= y and string.find(dir,"north") then
                dy = dy + 1
            elseif dy &lt;= y and string.find(dir,"south") then
                dy = dy - 1
            end
            if dz &gt;= z and string.find(dir,"up") then
                dz = dz + 1
            elseif dz &lt;= z and string.find(dir,"down") then
                dz = dz - 1
            end
            setRoomCoordinates(v,dx,dy,dz)
        end
    end
end

local function create_room(name, exits, dir, coords)
    -- makes a new room with captured name and exits
    -- links with other rooms as appropriate
    -- links to adjacent rooms in direction of exits if in simple mode
    if mapping then
        print("New Room: " .. name .. "\n")
        local newID = createRoomID()
        addRoom(newID)
        setRoomArea(newID, currentArea)
        setRoomName(newID, name)
        for k,v in ipairs(exits) do
            if stubmap[v] then
                if stubmap[v] &lt;= 12 then
                    setExitStub(newID, stubmap[v], true)
                else
                    -- check handling of custom exits here
                    setRoomUserData(newID, "stub"..v,stubmap[v])
                end
            end
        end
        if dir then
            connect_rooms(currentRoom, newID, dir)
        elseif find_portal or force_portal then
            addSpecialExit(currentRoom, newID, (find_portal or force_portal))
            setRoomUserData(newID,"portals",tostring(currentRoom)..":"..(find_portal or force_portal))
        end
        setRoomCoordinates(newID,unpack(coords))
        if not (find_portal or force_portal) and map.configs.stretch_map and table.size(getRoomsByPosition(currentArea,unpack(coords))) &gt; 1 then
            set_room(newID)
            stretch_map(dir,unpack(coords))
        end
        if map_mode == "simple" then
            local x,y,z = unpack(coords)
            local dx,dy,dz,rooms
            for k,v in ipairs(exits) do
                if v ~= dir then
                    dx,dy,dz = unpack(coordmap[stubmap[v]])
                    rooms = getRoomsByPosition(currentArea,x+dx,y+dy,z+dz)
                    if table.size(rooms) == 1 then
                        connect_rooms(newID,rooms[0],v)
                    end
                end
            end
        end
        set_room(newID)
    end
end

local function find_area_limits(areaID)
    -- used to find min and max coordinate limits for an area
    if not areaID then error("Find Limits: Missing area ID",2) end
    local rooms = getAreaRooms(areaID)
    local minx, miny, minz = getRoomCoordinates(rooms[0])
    local maxx, maxy, maxz = minx, miny, minz
    local x,y,z
    for k,v in pairs(rooms) do
        x,y,z = getRoomCoordinates(v)
        minx = math.min(x,minx)
        maxx = math.max(x,maxx)
        miny = math.min(y,miny)
        maxy = math.max(y,maxy)
        minz = math.min(z,minz)
        maxz = math.max(z,maxz)
    end
    return minx, maxx, miny, maxy, minz, maxz
end

local function find_link(name, exits, dir, max_distance)
    -- search for matching room in desired direction
    local x,y,z = getRoomCoordinates(currentRoom)
    if mapping and x then
        local dx,dy,dz = unpack(coordmap[stubmap[dir]])
        local minx, maxx, miny, maxy, minz, maxz = find_area_limits(currentArea)
        local rooms, match, stubs
        if max_distance then
            minx = x - max_distance
            maxx = x + max_distance
            miny = y - max_distance
            maxy = y + max_distance
            minz = z - max_distance
            maxz = z + max_distance
        end
        repeat
            x = x + dx
            y = y + dy
            z = z + dz
            rooms = getRoomsByPosition(currentArea,x,y,z)
        until (x &gt; maxx or x &lt; minx or y &gt; maxy or y &lt; miny or z &gt; maxz or z &lt; minz or not table.is_empty(rooms))
        for k,v in pairs(rooms) do
            if check_room(v,name,exits) then
                match = v
                break
            end
        end
        if match then
            connect_rooms(currentRoom, match, dir)
            set_room(match)
        else
            x,y,z = getRoomCoordinates(currentRoom)
            create_room(name, exits, dir,{x+dx,y+dy,z+dz})
        end
    end
end

local function get_recall()
    table.load(getMudletHomeDir() .. "/map_recalls.dat",map.recall)
    return map.recall[map.character]
end

local function move_map()
    -- tries to move the map to the next room
    local move = table.remove(move_queue,1)
    if move or random_move then
        local exits = (currentRoom and getRoomExits(currentRoom)) or {}
        -- check handling of custom exits here
        if currentRoom then
            for i = 13, #stubmap do
                exits[stubmap[i]] = tonumber(getRoomUserData(currentRoom,"exit " .. stubmap[i]))
            end
        end
        local special = (currentRoom and getSpecialExitsSwap(currentRoom)) or {}
        if move and not exits[move] and not special[move] then
            for k,v in pairs(special) do
                if string.starts(k,move) then
                    move = k
                    break
                end
            end
        end

        if find_portal then
            map.find_me(currentName,currentExits,move)
            find_portal = false
        elseif force_portal then
            find_portal = false
            print("CREATING PORTAL DESTINATION")
            create_room(currentName, currentExits, nil, {getRoomCoordinates(currentRoom)})
            force_portal = false
        elseif move == "recall" then
            set_room(get_recall())
        elseif move == "look" then
            map.find_me(currentName,currentExits)
        else
            if exits[move] and (vision_fail or check_room(exits[move], currentName, currentExits)) then
                set_room(exits[move])
            elseif special[move] and (vision_fail or check_room(special[move], currentName, currentExits)) then
                set_room(special[move])
            elseif not vision_fail then
                if mapping and move then
                    find_link(currentName, currentExits, move)
                else
                    map.find_me(currentName,currentExits, move)
                end
            end
        end
        vision_fail = false
    end
end

local function capture_move_cmd(dir,priority)
    -- captures valid movement commands
    dir = string.lower(dir)
    if dir == "/" then dir = "recall" end
    if dir == "l" then dir = "look" end
    if table.contains(exitmap,dir) or string.starts(dir,"enter ") or dir == "recall" then
        if priority then
            table.insert(move_queue,1,exitmap[dir] or dir)
        else
            table.insert(move_queue,exitmap[dir] or dir)
        end
    elseif map.configs.search_on_look and dir == "look" then
        table.insert(move_queue, dir)
    elseif currentRoom then
        local special = getSpecialExitsSwap(currentRoom) or {}
        if special[dir] then
            if priority then
                table.insert(move_queue,1,dir)
            else
                table.insert(move_queue,dir)
            end
        end
    end
end

local function capture_room_info(name, exits)
    -- captures room info, and tries to move map to match
    if (not vision_fail) and name and exits then
        prevName = currentName
        prevExits = currentExits
        name = string.trim(name)
        currentName = name
        exits = string.gsub(string.lower(exits)," and "," ")
        currentExits = (exits ~= "" and string.split(exits,"[, ]+")) or {}
        move_map()
    elseif vision_fail then
        move_map()
    end
end

local function find_area(name)
    -- searches for the named area, and creates it if necessary
    local areas = getAreaTable()
    local areaID
    for k,v in pairs(areas) do
        if string.lower(name) == string.lower(k) then
            areaID = v
            break
        end
    end
    if not areaID then areaID = addAreaName(name) end
    if not areaID then error("Invalid Area. No such area found, and area could not be added.") end
    currentArea = areaID
end

function map.load_map(use_local)
    local path = getMudletHomeDir() .. "/map.dat"
    if use_local then
        loadMap(path)
        print("Map reloaded from local copy.")
    else
        local address = map.configs.download_path .. "map.dat"
        downloading = true
        downloadFile(path,address)
        print("Downloading Map File.")
    end
end

function map.set_exit(dir,roomID)
    -- used to set unusual exits from the room you are standing in
    if mapping then
        roomID = assert(tonumber(roomID),"Set Exit: Invalid Room ID")
        if not table.contains(exitmap,dir) and not string.starts(dir, "-p ") then
            error("Set Exit: Invalid Direction")
        end

        if not string.starts(dir, "-p ") then
            local exit
            if stubmap[exitmap[dir] or dir] &lt;= 12 then
                exit = short[exitmap[dir] or dir]
                setExit(currentRoom,roomID,exit)
            else
                -- check handling of custom exits here
                exit = exitmap[dir] or dir
                exit = "exit " .. exit
                setRoomUserData(currentRoom,exit,roomID)
            end
            print("Exit " .. dir .. " now goes to roomID " .. roomID)
        else
            dir = string.gsub(dir,"^-p ","")
            addSpecialExit(currentRoom,roomID,dir)
            print("Special exit '" .. dir .. "' now goes to roomID " .. roomID)
        end
    end
end

function map.find_path(roomName,areaName,return_tables)
    areaName = (areaName ~= "" and areaName) or nil
    local rooms = find_room(roomName,areaName)
    local found,dirs = false,{}
    local path = {}
    for k,v in pairs(rooms) do
        found = getPath(currentRoom,k)
        if found and (#dirs == 0 or #dirs &gt; #speedWalkDir) then
            dirs = speedWalkDir
            path = speedWalkPath
        end
    end
    if return_tables then
        if table.is_empty(path) then
            path, dirs = nil, nil
        end
        return path, dirs
    else
        if #dirs &gt; 0 then
            print("Path to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ": " .. table.concat(dirs,", "))
        else
            print("No path found to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ".")
        end
    end
end

function map.export_area(name)
    -- used to export a single area to a file
    local areas = getAreaTable()
    name = string.lower(name)
    for k,v in pairs(areas) do
        if name == string.lower(k) then name = k end
    end
    if not areas[name] then error("No such area.") end
    local rooms = getAreaRooms(areas[name])
    local tmp = {}
    for k,v in pairs(rooms) do
        tmp[v] = v
    end
    rooms = tmp
    local tbl = {}
    tbl.name = name
    tbl.rooms = {}
    tbl.exits = {}
    tbl.special = {}
    local rname, exits, stubs, doors, special, portals, door_up, door_down, coords
    for k,v in pairs(rooms) do
        rname = getRoomName(v)
        exits = getRoomExits(v)
        stubs = getExitStubs(v)
        doors = getDoors(v)
        special = getSpecialExitsSwap(v)
        portals = getRoomUserData(v,"portals") or ""
        coords = {getRoomCoordinates(v)}
        tbl.rooms[v] = {name = rname, coords = coords, exits = exits, stubs = stubs, doors = doors, door_up = door_up, door_down = door_down, door_in = door_in, door_out = door_out, special = special, portals = portals}
        tmp = {}
        for k1,v1 in pairs(exits) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.exits[v] = tmp
        end
        tmp = {}
        for k1,v1 in pairs(special) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.special[v] = tmp
        end
    end
    local path = getMudletHomeDir().."/"..string.gsub(string.lower(name),"%s","_")..".dat"
    table.save(path,tbl)
    print("Area " .. name .. " exported to " .. path)
end

function map.import_area(name)
    name = getMudletHomeDir() .. "/" .. string.gsub(string.lower(name),"%s","_") .. ".dat"
    local tbl = {}
    table.load(name,tbl)
    local areas = getAreaTable()
    local areaID = areas[tbl.name] or addAreaName(tbl.name)
    local rooms = {}
    local ID
    for k,v in pairs(tbl.rooms) do
        ID = createRoomID()
        rooms[k] = ID
        addRoom(ID)
        setRoomName(ID,v.name)
        setRoomArea(ID,areaID)
        setRoomCoordinates(ID,unpack(v.coords))
        if type(v.stubs) == "table" then
            for i,j in pairs(v.stubs) do
                setExitStub(ID,j,true)
            end
        end
        for i,j in pairs(v.doors) do
            setDoor(ID,i,j)
        end
        setRoomUserData(ID,"portals",v.portals)
    end
    for k,v in pairs(tbl.rooms) do
        for i,j in pairs(v.exits) do
            if rooms[j] then
--                print("Setting Exit " .. rooms[k] .. " " .. rooms[j] .. " " .. i)
                connect_rooms(rooms[k],rooms[j],i)
            end
        end
        for i,j in pairs(v.special) do
            if rooms[j] then
                addSpecialExit(rooms[k],rooms[j],i)
            end
        end
    end
    for k,v in pairs(tbl.exits) do
        for i,j in pairs(v) do
            if getRoomName(j[1]) == j[2] then
                connect_rooms(rooms[k],j[1],i)
            end
        end
    end
    for k,v in pairs(tbl.special) do
        for i,j in pairs(v) do
            addSpecialExit(k,j[1],i)
        end
    end
    map.fix_portals()
    print("Area " .. tbl.name .. " imported from " .. name)
end

function map.set_recall()
    -- assigned the current room to be recall for the current character
    map.recall[map.character] = currentRoom
    table.save(getMudletHomeDir() .. "/map_recalls.dat",map.recall)
    print("Recall room set to: " .. getRoomName(currentRoom) .. ".")
end

function map.set_portal(name)
    -- creates a new portal in the room
    if mapping then
        if not string.starts(name,"-f ") then
            find_portal = name
        else
            name = string.gsub(name,"^-f ","")
            force_portal = name
        end
        move_queue = {name}
        send(name)
    end
end

function map.set_mode(mode)
    -- switches mapping modes
    if not table.contains({"simple","normal","complex"},mode) then error("Invalid Map Mode, must be 'simple', 'normal', or 'complex'.") end
    map_mode = mode
    print("Current mode set to: " .. mode)
end

function map.start_mapping(area_name)
    -- starts mapping, and sets the current area to the given one, or uses the current one
    if not currentName then
        print("Start Mapping Error: No room detected!")
        error("Start Mapping Error: No room detected!")
    end
    local rooms
    move_queue = {}
    area_name = area_name ~= "" and area_name or nil
    if currentArea and not area_name then
        local areas = getAreaTableSwap()
        area_name = areas[currentArea]
    end
    if not area_name then
        print("Start Mapping Error: No area set!")
        error("Start Mapping Error: No area set!")
    end
    print("Now mapping in area: " .. area_name)
    mapping = true
    find_area(area_name)
    rooms = find_room(currentName, currentArea)
    if table.is_empty(rooms) then
        if currentRoom and getRoomName(currentRoom) then
            map.set_area(area_name)
        else
            create_room(currentName, currentExits, nil, {0,0,0})
        end
    elseif currentRoom and currentArea ~= getRoomArea(currentRoom) then
        map.set_area(area_name)
    end
end

function map.stop_mapping()
    mapping = false
    print("Mapping off.")
end

function map.clear_moves()
    move_queue = {}
    print("Move queue cleared.")
end

function map.set_area(name)
    -- assigns the current room to the area given, creates the area if necessary
    if mapping then
        find_area(name)
        if currentRoom and getRoomArea(currentRoom) ~= currentArea then
            setRoomArea(currentRoom,currentArea)
            set_room(currentRoom)
        end
    end
end

function map.set_door(dir,status,one_way)
    -- adds a door on a given exit
    if mapping then
        if not currentRoom then error("Make Door: No room found.") end
        dir = exitmap[dir] or dir
        if not stubmap[dir] then error("Make Door: Invalid direction.") end
        status = (status ~= "" and status) or "closed"
        one_way = (one_way ~= "" and one_way) or "no"
        if not table.contains({"yes","no"},one_way) then error("Make Door: Invalid one-way status, must be yes or no.") end

        local exits = getRoomExits(currentRoom)
        local exit
        -- check handling of custom exits here
        for i = 13,#stubmap do
            exit = "exit " .. stubmap[i]
            exits[stubmap[i]] = tonumber(getRoomUserData(currentRoom,exit))
        end
        local target_room = exits[dir]
        if target_room then
            exits = getRoomExits(target_room)
            -- check handling of custom exits here
            for i = 13,#stubmap do
                exit = "exit " .. stubmap[i]
                exits[stubmap[i]] = tonumber(getRoomUserData(target_room,exit))
            end
        end
        if one_way == "no" and (target_room and exits[reverse_dirs[dir]] == currentRoom) then
            add_door(target_room,reverse_dirs[dir],status)
        end
        add_door(currentRoom,dir,status)
    end
end

function map.shift_room(dir)
    -- shifts a room around on the map
    if mapping then
        dir = assert(exitmap[dir] or (table.contains(exitmap,dir) and dir),"Exit Not Found")
        local x,y,z = getRoomCoordinates(currentRoom)
        dir = stubmap[dir]
        local coords = coordmap[dir]
        x = x + coords[1]
        y = y + coords[2]
        z = z + coords[3]
        setRoomCoordinates(currentRoom,x,y,z)
        centerview(currentRoom)
    end
end

local function check_link(firstID, secondID, dir)
    -- check to see if two rooms are connected in a given direction
    if not firstID then error("Check Link Error: No first ID",2) end
    if not secondID then error("Check Link Error: No second ID",2) end
    local name = getRoomName(firstID)
    local exits1 = table.union(getRoomExits(firstID),getRoomStubs(firstID))
    local exits2 = table.union(getRoomExits(secondID),getRoomStubs(secondID))
    local exit
    -- check handling of custom exits here
    for i = 13,#stubmap do
        exit = "exit " .. stubmap[i]
        exits1[stubmap[i]] = tonumber(getRoomUserData(firstID,exit))
        exits2[stubmap[i]] = tonumber(getRoomUserData(secondID,exit))
    end
    local checkID = exits2[reverse_dirs[dir]]
    local exits = {}
    for k,v in pairs(exits1) do
        table.insert(exits,k)
    end
    return checkID and check_room(checkID,name,exits)
end

function map.find_me(name, exits, dir)
    -- tries to locate the player using the current room name and exits, and if provided, direction of movement
    -- if direction of movement is given, narrows down possibilities using previous room info
    if move ~= "recall" then move_queue = {} end
    local check = dir and currentRoom and table.contains(exitmap,dir)
    name = name or currentName
    exits = exits or currentExits
    local rooms = find_room(name)
    local match_IDs = {}
    for k,v in pairs(rooms) do
        if check_room(k, name, exits) then
            table.insert(match_IDs,k)
        end
    end
    rooms = match_IDs
    match_IDs = {}
    if table.size(rooms) &gt; 1 and check then
        for k,v in pairs(rooms) do
            if check_link(currentRoom,v,dir) then
                table.insert(match_IDs,v)
            end
        end
    elseif random_move then
        for k,v in pairs(getRoomExits(currentRoom)) do
            if check_room(v,currentName,currentExits) then
                table.insert(match_IDs,v)
            end
        end
    end
    if table.size(match_IDs) == 0 then
        match_IDs = rooms
    end
    if table.contains(match_IDs,currentRoom) then
        match_IDs = {currentRoom}
    end
    if not table.is_empty(match_IDs) and not find_portal then
        set_room(match_IDs[1])
    elseif find_portal then
        if not table.is_empty(match_IDs) then
            print("FOUND PORTAL DESTINATION, LINKING ROOMS")
            addSpecialExit(currentRoom,match_IDs[1],find_portal)
            local portals = getRoomUserData(match_IDs[1],"portals") or ""
            portals = portals .. "," .. tostring(currentRoom)..":"..find_portal
            setRoomUserData(match_IDs[1],"portals",portals)
            set_room(match_IDs[1])
        else
            print("CREATING PORTAL DESTINATION")
            create_room(currentName, currentExits, nil, {getRoomCoordinates(currentRoom)})
        end
        find_portal = false
    end
end

function map.fix_portals()
    if mapping then
        -- used to clear and update data for portal back-referencing
        local rooms = getRooms()
        local portals
        for k,v in pairs(rooms) do
            setRoomUserData(k,"portals","")
        end
        for k,v in pairs(rooms) do
            for cmd,room in pairs(getSpecialExitsSwap(k)) do
                portals = getRoomUserData(room,"portals") or ""
                if portals ~= "" then portals = portals .. "," end
                portals = portals .. tostring(k) .. ":" .. cmd
                setRoomUserData(room,"portals",portals)
                --print(room,portals)
            end
        end
    end
end

function map.merge_rooms()
    -- used to combine essentially identical rooms with the same coordinates
    -- typically, these are generated due to mapping errors
    if mapping then
        local x,y,z = getRoomCoordinates(currentRoom)
        local rooms = getRoomsByPosition(currentArea,x,y,z)
        local exits, portals,room,cmd,curportals
        for k,v in pairs(rooms) do
            if v ~= currentRoom then
                if getRoomName(v) == getRoomName(currentRoom) then
                    for k1,v1 in pairs(getRoomExits(v)) do
                        setExit(currentRoom,v1,stubmap[k1])
                        exits = getRoomExits(v1)
                        if exits[reverse_dirs[k1]] == v then
                            setExit(v1,currentRoom,stubmap[reverse_dirs[k1]])
                        end
                    end
                    for k1,v1 in pairs(getDoors(v)) do
                        setDoor(currentRoom,k1,v1)
                    end
                    for k1,v1 in pairs(getSpecialExitsSwap(v)) do
                        addSpecialExit(currentRoom,v1,k1)
                    end
                    portals = getRoomUserData(v,"portals") or ""
                    if portals ~= "" then
                        portals = string.split(portals,",")
                        for k1,v1 in ipairs(portals) do
                            room,cmd = unpack(string.split(v1,":"))
                            addSpecialExit(tonumber(room),currentRoom,cmd)
                            curportals = getRoomUserData(currentRoom,"portals") or ""
                            if not string.find(curportals,room) then
                                curportals = curportals .. "," .. room .. ":" .. cmd
                                setRoomUserData(currentRoom,"portals",curportals)
                            end
                        end
                    end
                    -- check handling of custom exits here for doors and exits, and reverse exits
                    for i = 13,#stubmap do
                        local door = "door " .. stubmap[i]
                        local tmp = tonumber(getRoomUserData(v,door))
                        if tmp then
                            setRoomUserData(currentRoom,door,tmp)
                        end
                        local exit = "exit " .. stubmap[i]
                        tmp = tonumber(getRoomUserData(v,exit))
                        if tmp then
                            setRoomUserData(currentRoom,exit,tmp)
                            if tonumber(getRoomUserData(tmp, "exit " .. reverse_dirs[stubmap[i]])) == v then
                                setRoomUserData(tmp, exit, currentRoom)
                            end
                        end
                    end
                    deleteRoom(v)
                end
            end
        end
    end
end

function doSpeedWalk()
    -- we can do a lot here, this fires when a room is double clicked on, and is intended to speedwalk to it
    print("Path to " .. getRoomName(speedWalkPath[#speedWalkPath]) .. ": " .. table.concat(speedWalkDir, ", "))
end

function map.eventHandler(event,...)
    if event == "onPrompt" and room_detected then
        room_detected = false
        capture_room_info(map.prompt.room, map.prompt.exits)
    elseif event == "onMoveFail" then
        table.remove(move_queue,1)
    elseif event == "onVisionFail" then
        vision_fail = true
        room_detected = true
    elseif event == "onRandomMove" then
        random_move = true
        move_queue = {}
    elseif event == "onForcedMove" then
        capture_move_cmd(arg[1],arg[2]=="true")
    elseif event == "onNewRoom" then
        room_detected = true
    elseif event == "sysDataSendRequest" then
        capture_move_cmd(arg[1])
    elseif event == "sysDownloadDone" and downloading then
        loadMap(getMudletHomeDir() .. "/map.dat")
        downloading = false
        print("Map File Loaded.")
    elseif event == "sysConnectionEvent" or event == "sysInstall" then
        config()
    end
end

registerAnonymousEventHandler("sysDownloadDone", "map.eventHandler")
registerAnonymousEventHandler("sysConnectionEvent", "map.eventHandler")
registerAnonymousEventHandler("sysInstall", "map.eventHandler")
registerAnonymousEventHandler("sysDataSendRequest", "map.eventHandler")
registerAnonymousEventHandler("onPrompt", "map.eventHandler")
registerAnonymousEventHandler("onMoveFail"," map.eventHandler")
registerAnonymousEventHandler("onVisionFail"," map.eventHandler")
registerAnonymousEventHandler("onRandomMove"," map.eventHandler")
registerAnonymousEventHandler("onForcedMove"," map.eventHandler")
registerAnonymousEventHandler("onNewRoom"," map.eventHandler")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Utilities</name>
				<packageName></packageName>
				<script>function dhb.mapecho(what)
  what = what or ""
  moveCursorEnd("main") if getCurrentLine() ~= "" then echo"\n" end
  decho("&lt;112,229,0&gt;(&lt;73,149,0&gt;маппер&lt;112,229,0&gt;): &lt;255,255,255&gt;")
  cecho(tostring(what))
  echo("\n")
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>speedwalking</name>
				<packageName></packageName>
				<script>function doSpeedWalk()
    -- we can do a lot here, this fires when a room is double clicked on, and is intended to speedwalk to it
    cecho("Path to &lt;DimGray&gt;" .. getRoomName(speedWalkPath[#speedWalkPath]) .. "&lt;reset&gt;: " .. table.concat(speedWalkDir, ", "))
		dhb.speedWalkDir = table.deepcopy(speedWalkDir)
		dhb.speedWalkPath = table.deepcopy(speedWalkPath)
		dhb.tabletonumber(dhb.speedWalkPath)
		
		speedWalkWatch = speedWalkWatch or createStopWatch()
		resetStopWatch(speedWalkWatch)
    startStopWatch(speedWalkWatch)
		
		speedWalkCounter = 1
		dhb.autowalking = true
		dhb.move()
end

local oldnum
function speedwalking(_, currentRoom)
  local num = tonumber(currentRoom)
  if num ~= dhb.currentroom then dhb.previousroom = dhb.currentroom end
  dhb.currentroom = num
  dhb.currentroomname = getRoomName(num)

  if oldnum == num then return else oldnum = num end
  if not dhb.autowalking then return end

  if dhb.movetimer then killTimer(dhb.movetimer); dhb.movetimer = false end
  print(dhb.speedWalkPath[speedWalkCounter], num)
  if num == dhb.speedWalkPath[#dhb.speedWalkPath] then
    local walktime = stopStopWatch(speedWalkWatch)
    dhb.mapecho(string.format("Приехали! Всего %.1fс.\n", walktime))
    raiseEvent("mmapper arrived")
    dhb.speedWalkPath = {}
    dhb.speedWalkDir = {}
    speedWalkCounter = 0
    dhb.autowalking = false
  elseif dhb.speedWalkPath[speedWalkCounter] == num then
    speedWalkCounter = speedWalkCounter + 1
    dhb.move()
  elseif #dhb.speedWalkPath&gt; 0 then -- ended up somewhere we didn't want to be
    speedWalkMoved = false
    -- re-calculate path then
    dhb.mapecho("Ended up off the path, recalculating a new path...")
    local destination = dhb.speedWalkPath[#dhb.speedWalkPath]
    if not getPath(num, destination) then
      dhb.mapecho(string.format("Don't know how to get to %d (%s) anymore :( Move into a room we know of to continue",
        destination, getRoomName(destination)))
    else
      gotoRoom(destination)
    end
  end
end

function dhb.stopwalking()
  dhb.speedWalkPath = {}
  dhb.speedWalkDir = {}
  speedWalkCounter = 0
  stopStopWatch(speedWalkWatch)
  if dhb.movetimer then killTimer(dhb.movetimer) end
	dhb.movetimer = nil
  dhb.autowalking = false

  dhb.mapecho("Stopped walking.")
  raiseEvent("dhb mapper stopped")
end

function dhb.move()
  if dhb.movepaused or dhb.movetimer then return end
  if speedWalkCounter == 0 then speedWalkCounter = 1 end
	
  cmd = dhb.speedWalkDir[speedWalkCounter]

  -- timeout before loadstring, so it can set its own if it would like to.
  dhb.setmovetimer()
	
	send(cmd, false)
	cecho(string.format("&lt;red&gt;(&lt;maroon&gt;%d - &lt;dark_slate_grey&gt;%s&lt;red&gt;)",
	  #dhb.speedWalkDir - speedWalkCounter + 1, cmd))
end

function dhb.setmovetimer(time)
  if dhb.movetimer then killTimer(dhb.movetimer) end

  dhb.movetimer = tempTimer(getNetworkLatency()+(time or 0.5), function ()
    dhb.movetimer = false
    dhb.move()
  end)
end

function dhb.tabletonumber(tbl)
  for k,v in pairs(tbl) do tbl[k] = tonumber(v) end
end</script>
				<eventHandlerList>
					<string>onMoveMap</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>YATCOCONFIG</name>
			<packageName></packageName>
			<script>demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.config = demonnic.chat.config or {}</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Configuration Options (container)</name>
				<packageName></packageName>
				<script>dhb.ui.mapchat = Geyser.Container:new({
  name = "dhb.ui.mapchat",
	x = "-40%",
  y = 0,
  width = "30%",
  height = "80%"
})

dhb.ui.chat = Geyser.Container:new({
  name = "dhb.ui.chat",
	x = 0,
	y = "50%",
	width = "100%",
	height = "50%"
}, dhb.ui.mapchat)

dhb.ui.mapper = Geyser.Mapper:new({
  name = "dhb.ui.mapper",
  x = 0, y = 0,
  width = "100%",
  height = "50%%",
}, dhb.ui.mapchat)

-- reposition timer after YATCO is up
tempTimer(1, function() dhb.ui.mapper:reposition() end)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Configuration Options</name>
				<packageName></packageName>
				<script>--[[
This is a table of channels you would like.
AKA the place you tell the script what tabs you want.
Each entry must be a string. The defaults should be a pretty effective guide.
]]

demonnic.chat.config.channels = {
  "All",
	"OOC",
  "City",
  "Auction",
}

--[[
This is where all of the configuration options can be set. 
Anything I've put in this script object can be changed, but please do pay attention to what you're doing.
If you change one of the values to something it shouldn't be, you could break it. 
]]

--This is where you tell it to use tabbed chat.
demonnic.chat.use = true

--[[
This is where you put what container to put the tabbed chat stuff into. Make it
equal to the actual container object you want it in, or false for none. Defaults to false
Which is to say if you want to put the tabbed chat stuff into a container made using 
uiRight = Geyser.Container:new()

you would put

demonnic.chat.useContainer = uiRight

and if you don't want it in a container you would put

demonnic.chat.useContainer = false
]]

demonnic.chat.useContainer = dhb.ui.chat

--[[
The timestamp option is set here.
Set to false if you do not want any timestamps displayed for chat.
If you do want it displayed, set to the string for the format you wish. 
see http://wiki.mudlet.org/w/Manual:Lua_Functions#getTime for information
how to format the string
]]
demonnic.chat.config.timestamp = "HH:mm:ss"

--[[ Should we use our own colors for the timestamp?
Set to true if you want to specify foreground and background colors
for the timestamp.
Set to false if you want the timestamps background and foreground
colors to match that of the mud output.
]]
demonnic.chat.config.timestampCustomColor = false
--[[
and what foreground color? You can either use one of the 'named' colors
(see http://wiki.mudlet.org/images/c/c3/ShowColors.png for available colors)
demonnic.chat.config.timestampFG = "slate_grey"

Or you can use a table of R,G,B values. 
demonnic.chat.config.timestampFG = {
  255,
    0,
    0,
}
then the foreground for the timestamp would be 255 read, 100 green, and 0 blue
]]
demonnic.chat.config.timestampFG = "red"

--and background? Same rules as for the foreground above
demonnic.chat.config.timestampBG = "blue"

--[[
This is where you say what corner of the screen you want the tabbed chat on
Valid settings are "topright", "topleft", "bottomright", "bottomleft"
]]--
demonnic.chat.config.location = "topright"



--Set this to the name of the channel you want to have everything sent to. 
--Per the default, this would be the "All" channel. If you have a different name for it:
--
--demonnic.chat.config.Alltab = "Bucket"  
--
--And if you don't want it turned on at all:
--
--demonnic.chat.config.Alltab = false

demonnic.chat.config.Alltab = "All"

--Set this to the name of the channel you want to display your map. Set to "" if you
--don't want to display the map in your YATCO tabs
demonnic.chat.config.Maptab = ""


---------------------------------------------------------------------------------
--                                                                             --
--The infamous blinking stuff!!!                                               --
--                                                                             --
---------------------------------------------------------------------------------

--[[
Do you want tabs to blink when you get new messages, until you click on the tab?
True if yes, false if no.
]]
demonnic.chat.config.blink = true

--How long (in seconds) between blinks? For example, 1 would mean a 1 second pause in between blinks.
demonnic.chat.config.blinkTime = 3

--Blink if the bucket tab ("All" by default, but configured above) is in focus?
demonnic.chat.config.blinkFromAll = false




--Font size for the chat messages

demonnic.chat.config.fontSize = 9

--[[
Should we preserve the formatting of the text. 
Or should we set the background of it to match the window color?
Set this to false if you want the background for all chat to match the background of the window.
Useful if you change the background from black, and don't like the way the pasted chat makes blocks in it
]]

demonnic.chat.config.preserveBackground = false

--[[
Gag the chat lines in the main window?
defaults to false, set to true if you want to gag.
]]

demonnic.chat.config.gag = false

--[[
Number of lines of chat visible at once. 
Will determine how tall the window for the chats is.
]]

demonnic.chat.config.lines = 45

--[[
Number of characters to wrap the chatlines at.
This will also determine how wide the chat windows are.
]]

demonnic.chat.config.width = 60

--[[
Set the color for the active tab. R,G,B format.
The default here is a brightish green
]]

demonnic.chat.config.activeColors = {
  r = 0,
  g = 180,
  b = 0,
}

--[[
Set the color for the inactive tab. R,G,B format.
The default here is a drab grey
]]

demonnic.chat.config.inactiveColors = {
  r = 60,
  g = 60,
  b = 60,
}

--[[
Set the color for the chat window itself. R,G,B format.
Defaulted to the black of my twisted hardened soul. Or something.
]]

demonnic.chat.config.windowColors = {
  r = 0,
  g = 0,
  b = 0,
}

--[[
Set the color for the text on the active tab. Uses color names.
Set the default to purple. So the tab you're looking at, by default will be purple on bright green. 
Did I mention I'm a bit colorblind?
]]

demonnic.chat.config.activeTabText = "purple"

--[[
Set the color for the text on the inactive tabs. Uses color names.
Defaulted this to white. So the tabs you're not looking at will be white text on boring grey background.
]]

demonnic.chat.config.inactiveTabText = "white"

--[[
have to make sure a currentTab is set... 
so we'll use the one for the bucket, or the first one in the channels table
Or, you know... what it's currently set to, if it's already set.
]]
demonnic.chat.currentTab = demonnic.chat.currentTab or demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Demonnic</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Shared</name>
				<packageName></packageName>
				<script>--Bootstrapping variables/etc. Don't touch this unless you really know what you're doing

--I mean it. I'll point. AND laugh. loudly. 
demonnic = demonnic or {}
demonnic.config = demonnic.config or {}
demonnic.balances = demonnic.balances or {}
demonnic.balances.balance = demonnic.balances.balance or 1
demonnic.balances.equilibrium = demonnic.balances.equilibrium or 1
demonnic.debug = demonnic.debug or {}
demonnic.debug.active = demonnic.debug.active or nil
demonnic.debug.categories = demonnic.debug.categories or { }


function demonnic:echo(msg)
 cecho(string.format("\n&lt;blue&gt;(&lt;green&gt;Demonnic&lt;blue&gt;):&lt;white&gt; %s", msg))
end</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Debugging</name>
					<packageName></packageName>
					<script>--Adds debugging functionality 

function demonnic:Debug(category,debugData)
   if category then
      if table.contains(demonnic.debug.categories, category) then
         if type(debugData) == "table" then
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt;")
            display(debugData)
         elseif type(debugData) == "string" or type(debugData) == "number" then
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt; " .. debugData .. "\n" )
         else
            demonnic:echo("&lt;red&gt;DEBUG " .. category .. ":&lt;white&gt; " .. tostring(debugData) .. "\n" )
         end
      end
   else
      if type(debugData) == "table" then
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt;")
         display(debugData)
      elseif type(debugData) == "string" or type(debugData) == "number" then
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt; " .. debugData)
      else
         demonnic:echo("&lt;red&gt;DEBUG:&lt;white&gt; " .. tostring(debugData))
      end
   end
end

function demonnic:printDebug(category, debugData)
   if not demonnic.debug.active then return end
   demonnic:Debug(category, debugData)
end

function demonnic:toggleDebug()
   if demonnic.debug.active then demonnic.debug.active = nil
   else demonnic.debug.active = true
   end
   demonnic:echo("Debugging is currently " .. (( demonnic.debug.active and "&lt;green&gt;ON&lt;white&gt;") or "&lt;red&gt;OFF&lt;white&gt;"))
end

function demonnic:watchCategory( category )
   if table.contains(demonnic.debug.categories, category) then
      for i,v in ipairs(demonnic.debug.categories) do
         if v == category then
            table.remove(demonnic.debug.categories, i)
         end
      end
      demonnic:echo("No longer watching the '&lt;red&gt;"..category.."&lt;white&gt;' category.") 
   else
      table.insert(demonnic.debug.categories, category)
      demonnic:echo("Now watching the '&lt;red&gt;"..category.."&lt;white&gt;' category.")
   end
   demonnic:echo("Debugging is currently " .. (( demonnic.debug.active and "&lt;green&gt;ON&lt;white&gt;") or "&lt;red&gt;OFF&lt;white&gt;"))
end

function demonnic:listCategories()
   if #demonnic.debug.categories &gt; 0 then
      demonnic:echo("You are currently watching the following categories:\n" .. table.concat(demonnic.debug.categories,", ") )
   else
      demonnic:echo("You are not watching any debugs.")
   end
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Geyser Additions</name>
					<packageName></packageName>
					<script>function Geyser.MiniConsole:clear()
   clearWindow(self.name)
end

function Geyser.MiniConsole:append()
  appendBuffer(self.name)
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Tabbed Chat</name>
				<packageName></packageName>
				<script>--Do not remove the following lines. Or change them.
demonnic = demonnic or {}
demonnic.chat = demonnic.chat or {}
demonnic.chat.tabsToBlink = demonnic.chat.tabsToBlink or {}
demonnic.chat.tabs = demonnic.chat.tabs or {}
demonnic.chat.windows = demonnic.chat.windows or {}
if not demonnic.chat.config then
  cecho("&lt;red:white&gt;YOU DO NOT HAVE THE YATCO CONFIG PACKAGE IN PLACE. THINGS WILL NOT WORK AS EXPECTED\n\n")
  demonnic.chat.error = "NO CONFIG"
end</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Code</name>
					<packageName></packageName>
					<script>--[[
If the label callbacks ever decide to start taking a function which is part of a table, 0then this will change.
Or if it's modified to take actual functions. Anonymouse function clickcallback would be awfully nice.
]]

function demonnicChatSwitch(chat)
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local newr = demonnic.chat.config.activeColors.r
  local newg = demonnic.chat.config.activeColors.g
  local newb = demonnic.chat.config.activeColors.b
  local oldchat = demonnic.chat.currentTab
  if demonnic.chat.currentTab ~= chat then
    demonnic.chat.windows[oldchat]:hide()
    demonnic.chat.tabs[oldchat]:setColor(r,g,b)
    demonnic.chat.tabs[oldchat]:echo(oldchat, demonnic.chat.config.inactiveTabText, "c")
    if demonnic.chat.config.blink and demonnic.chat.tabsToBlink[chat] then
      demonnic.chat.tabsToBlink[chat] = nil
    end
    if demonnic.chat.config.blink and chat == demonnic.chat.config.Alltab then
      demonnic.chat.tabsToBlink = {}
    end
  end
  demonnic.chat.tabs[chat]:setColor(newr,newg,newb)
  demonnic.chat.tabs[chat]:echo(chat, demonnic.chat.config.activeTabText, "c")
  demonnic.chat.windows[chat]:show()
  demonnic.chat.currentTab = chat  
end

function demonnic.chat:resetUI()
  demonnic.chat.container = demonnic.chat.useContainer or Geyser.Container:new(demonnic.chat[demonnic.chat.config.location]())
  demonnic.chat.tabBox = Geyser.HBox:new({
    x=0,
    y=0,
    width = "100%",
    height = "25px",
    name = "DemonChatTabs",
  },demonnic.chat.container)

end

function demonnic.chat:create()
  --reset the UI
  demonnic.chat:resetUI()
  --Set some variables locally to increase readability
  local r = demonnic.chat.config.inactiveColors.r
  local g = demonnic.chat.config.inactiveColors.g
  local b = demonnic.chat.config.inactiveColors.b
  local winr = demonnic.chat.config.windowColors.r
  local wing = demonnic.chat.config.windowColors.g
  local winb = demonnic.chat.config.windowColors.b

  --iterate the table of channels and create some windows and tabs
  for i,tab in ipairs(demonnic.chat.config.channels) do
    demonnic.chat.tabs[tab] = Geyser.Label:new({
      name=string.format("tab%s", tab),
    }, demonnic.chat.tabBox)
    demonnic.chat.tabs[tab]:echo(tab, demonnic.chat.config.inactiveTabText, "c")
    demonnic.chat.tabs[tab]:setColor(r,g,b)
    demonnic.chat.tabs[tab]:setClickCallback("demonnicChatSwitch", tab)
    demonnic.chat.windows[tab] = Geyser.MiniConsole:new({
--      fontSize = demonnic.chat.config.fontSize,
      x = 0,
      y = 25,
      height = "100%",
      width = "100%",
      name = string.format("win%s", tab),
    }, demonnic.chat.container)
    demonnic.chat.windows[tab]:setFontSize(demonnic.chat.config.fontSize)
    demonnic.chat.windows[tab]:setColor(winr,wing,winb)
    demonnic.chat.windows[tab]:setWrap(demonnic.chat.config.width)
    demonnic.chat.windows[tab]:hide()
  end
  if demonnic.chat.config.Maptab and demonnic.chat.config.Maptab ~= "" then
    demonnic.chat.mapWindow = Geyser.Mapper:new({
      x = 0,
      y = 0,
      height = "100%",
      width = "100%",
    }, demonnic.chat.windows[demonnic.chat.config.Maptab])
    demonnic.chat.windows[demonnic.chat.config.Maptab]:hide()
  end
  local showme = demonnic.chat.config.Alltab or demonnic.chat.config.channels[1]
  demonnicChatSwitch(showme)
  --start the blink timers, if enabled
  if demonnic.chat.config.blink and not demonnic.chat.blinkTimerOn then
    demonnic.chat:blink()
  end
end

function demonnic.chat:append(chat)
  local r = demonnic.chat.config.windowColors.r
  local g = demonnic.chat.config.windowColors.g
  local b = demonnic.chat.config.windowColors.b
  selectCurrentLine()
  local ofr,ofg,ofb = getFgColor()
  local obr,obg,obb = getBgColor()
  if demonnic.chat.config.preserveBackground then
    setBgColor(r,g,b)
  end
  copy()
  if demonnic.chat.config.timestamp then
    local timestamp = getTime(true, demonnic.chat.config.timestamp)
    local tsfg = {}
    local tsbg = {}
    local colorLeader = ""
    if demonnic.chat.config.timestampCustomColor then
      if type(demonnic.chat.config.timestampFG) == "string" then
        tsfg = color_table[demonnic.chat.config.timestampFG]
      else
        tsfg = demonnic.chat.config.timestampFG
      end
      if type(demonnic.chat.config.timestampBG) == "string" then
        tsbg = color_table[demonnic.chat.config.timestampBG]
      else
        tsbg = demonnic.chat.config.timestampBG
      end
      colorLeader = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;",tsfg[1],tsfg[2],tsfg[3],tsbg[1],tsbg[2],tsbg[3])
    else
      colorLeader = string.format("&lt;%s,%s,%s:%s,%s,%s&gt;",ofr,ofg,ofb,obr,obg,obb)
    end
    local fullstamp = string.format("%s%s",colorLeader,timestamp)
      demonnic.chat.windows[chat]:decho(fullstamp)
      demonnic.chat.windows[chat]:echo(" ")
      if demonnic.chat.config.Alltab then 
        demonnic.chat.windows[demonnic.chat.config.Alltab]:decho(fullstamp)
        demonnic.chat.windows[demonnic.chat.config.Alltab]:echo(" ")
      end
  end
  demonnic.chat.windows[chat]:append()
  if demonnic.chat.config.gag then 
    deleteLine() 
    tempLineTrigger(1,1, [[if isPrompt() then deleteLine() end]])
  end
  if demonnic.chat.config.Alltab then appendBuffer(string.format("win%s", demonnic.chat.config.Alltab)) end
  if demonnic.chat.config.blink and chat ~= demonnic.chat.currentTab then 
    if (demonnic.chat.config.Alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end



function demonnic.chat:blink()
  if demonnic.chat.blinkID then killTimer(demonnic.chat.blinkID) end
  if not demonnic.chat.config.blink then 
    demonnic.chat.blinkTimerOn = false
    return 
  end
  if not demonnic.chat.container.hidden then
    for tab,_ in pairs(demonnic.chat.tabsToBlink) do
      demonnic.chat.tabs[tab]:flash()
    end
  end
  demonnic.chat.blinkID = tempTimer(demonnic.chat.config.blinkTime, function () demonnic.chat:blink() end)
end

function demonnic.chat:topright()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=string.format("-%sc",demonnic.chat.config.width + 2),
    y=0,
    width="-15px",
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:topleft()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=0,
    y=0,
    width=string.format("%sc",demonnic.chat.config.width),
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:bottomright()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=string.format("-%sc",demonnic.chat.config.width + 2),
    y=string.format("-%sc",demonnic.chat.config.lines + 2),
    width="-15px",
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end

function demonnic.chat:bottomleft()
  return {
    fontSize = demonnic.chat.config.fontSize,
    x=0,
    y=string.format("-%sc",demonnic.chat.config.lines + 2),
    width=string.format("%sc",demonnic.chat.config.width),
    height=string.format("%ic", demonnic.chat.config.lines + 2),
  }
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>demonnicOnStart</name>
					<packageName></packageName>
					<script>function demonnicOnStart()
  if demonnic.chat.use then
    demonnic.chat:create()
  end
end</script>
					<eventHandlerList>
						<string>sysLoadEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>echo functions</name>
					<packageName></packageName>
					<script>
function demonnic.chat:cecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  cecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    cecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:decho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  decho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    decho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end

function demonnic.chat:hecho(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  hecho(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    hecho(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end


function demonnic.chat:echo(chat, message)
  local alltab = demonnic.chat.config.Alltab
  local blink = demonnic.chat.config.blink
  echo(string.format("win%s",chat), message)
  if alltab and chat ~= alltab then 
    echo(string.format("win%s", alltab), message)
  end
  if blink and chat ~= demonnic.chat.currentTab then
    if (alltab == demonnic.chat.currentTab) and not demonnic.chat.config.blinkOnAll then
      return
    else
      demonnic.chat.tabsToBlink[chat] = true
    end
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>demonnicOnInstall</name>
					<packageName></packageName>
					<script>function demonnicOnInstall(_, package)
  if package:find("YATCO") then
  	demonnicOnStart()
  end
end</script>
					<eventHandlerList>
						<string>sysInstall</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
